import fs from "fs";
import path from "path";
import { JS_EXTENSIONS, ensureAbsolutePath, findExists } from "@modern-js/utils";
import { ENTRY_FILE_NAME, INDEX_FILE_NAME } from "./constants";
import { isDefaultExportFunction } from "./isDefaultExportFunction";
const hasIndex = (dir) => findExists(JS_EXTENSIONS.map((ext) => path.resolve(dir, `${INDEX_FILE_NAME}${ext}`)));
const hasEntry = (dir) => findExists(JS_EXTENSIONS.map((ext) => path.resolve(dir, `${ENTRY_FILE_NAME}${ext}`)));
const hasServerEntry = (dir) => findExists(JS_EXTENSIONS.map((ext) => path.resolve(dir, `${ENTRY_FILE_NAME}.server${ext}`)));
const isBundleEntry = async (hookRunners, dir, enableCustomEntry) => {
  const { entry } = await hookRunners.checkEntryPoint({
    path: dir,
    entry: false
  });
  if (entry) {
    return entry;
  }
  const customEntry = hasEntry(dir);
  if (enableCustomEntry && customEntry) {
    return customEntry;
  }
  return hasIndex(dir);
};
const scanDir = async (hookRunners, dirs, enableCustomEntry) => {
  const entries = await Promise.all(dirs.map(async (dir) => {
    const indexFile = hasIndex(dir);
    const customBootstrap = isDefaultExportFunction(indexFile) ? indexFile : false;
    const entryName = path.basename(dir);
    const customEntryFile = hasEntry(dir);
    const customServerEntry = hasServerEntry(dir);
    if (indexFile && !customBootstrap) {
      return {
        entryName,
        isMainEntry: false,
        entry: indexFile,
        absoluteEntryDir: path.resolve(dir),
        isAutoMount: false,
        customBootstrap
      };
    }
    const entryFile = (await hookRunners.checkEntryPoint({
      path: dir,
      entry: false
    })).entry;
    if (entryFile) {
      return {
        entryName,
        isMainEntry: false,
        entry: enableCustomEntry ? customEntryFile || entryFile : entryFile,
        customServerEntry,
        absoluteEntryDir: path.resolve(dir),
        isAutoMount: true,
        customBootstrap,
        customEntry: enableCustomEntry ? Boolean(customEntryFile) : false
      };
    }
    if (enableCustomEntry && customEntryFile) {
      return {
        entryName,
        isMainEntry: false,
        entry: customEntryFile,
        customServerEntry,
        absoluteEntryDir: path.resolve(dir),
        isAutoMount: false,
        customEntry: Boolean(customEntryFile)
      };
    }
    return false;
  })).then((entries2) => entries2.filter(Boolean));
  if (entries.length === 0) {
    throw Error("There is no valid entry point in the current project!");
  }
  return entries;
};
const getFileSystemEntry = async (hookRunners, appContext, config) => {
  const { appDirectory } = appContext;
  const { source: { entriesDir, disableEntryDirs, enableCustomEntry } } = config;
  let disabledDirs = [];
  if (disableEntryDirs && Array.isArray(disableEntryDirs)) {
    disabledDirs = disableEntryDirs === null || disableEntryDirs === void 0 ? void 0 : disableEntryDirs.map((dir) => ensureAbsolutePath(appDirectory, dir));
  }
  const src = ensureAbsolutePath(appDirectory, entriesDir || "");
  if (fs.existsSync(src)) {
    if (fs.statSync(src).isDirectory()) {
      if (await isBundleEntry(hookRunners, src, enableCustomEntry)) {
        return scanDir(hookRunners, [
          src
        ], enableCustomEntry);
      }
      const dirs = [];
      await Promise.all(fs.readdirSync(src).map(async (filename) => {
        const file = path.join(src, filename);
        if (fs.statSync(file).isDirectory() && await isBundleEntry(hookRunners, file, enableCustomEntry) && !disabledDirs.includes(file)) {
          dirs.push(file);
        }
      }));
      return scanDir(hookRunners, dirs, enableCustomEntry);
    } else {
      throw Error(`source.entriesDir accept a directory.`);
    }
  } else {
    throw Error(`src dir ${entriesDir} not found.`);
  }
};
export {
  getFileSystemEntry
};
