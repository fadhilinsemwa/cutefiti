"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var apps_exports = {};
__export(apps_exports, {
  generateApps: () => generateApps,
  pathJoin: () => pathJoin
});
module.exports = __toCommonJS(apps_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_runtime = require("@meta/runtime");
var import_garfish = __toESM(require("garfish"));
var import_react = require("react");
var import_util = require("../../util");
var import_loadable = require("../loadable");
function pathJoin(...args) {
  const res = args.reduce((res2, path) => {
    let nPath = path;
    if (!nPath || typeof nPath !== "string") {
      return res2;
    }
    if (nPath[0] !== "/") {
      nPath = `/${nPath}`;
    }
    const lastIndex = nPath.length - 1;
    if (nPath[lastIndex] === "/") {
      nPath = nPath.substring(0, lastIndex);
    }
    return res2 + nPath;
  }, "");
  return res || "/";
}
function getAppInstance(options, appInfo, manifest) {
  let locationHref = "";
  function MicroApp(props) {
    var _context_router, _context_router1, _context_router2, _context_router3, _context_router4;
    const appRef = (0, import_react.useRef)(null);
    const domId = (0, import_util.generateSubAppContainerKey)(appInfo);
    const [SubModuleComponent, setSubModuleComponent] = (0, import_react.useState)();
    const context = (0, import_react.useContext)(import_runtime.RuntimeReactContext);
    var _props_useRouteMatch;
    const useRouteMatch = (_props_useRouteMatch = props.useRouteMatch) !== null && _props_useRouteMatch !== void 0 ? _props_useRouteMatch : context === null || context === void 0 ? void 0 : (_context_router = context.router) === null || _context_router === void 0 ? void 0 : _context_router.useRouteMatch;
    var _props_useMatches;
    const useMatches = (_props_useMatches = props.useMatches) !== null && _props_useMatches !== void 0 ? _props_useMatches : context === null || context === void 0 ? void 0 : (_context_router1 = context.router) === null || _context_router1 === void 0 ? void 0 : _context_router1.useMatches;
    var _props_useLocation;
    const useLocation = (_props_useLocation = props.useLocation) !== null && _props_useLocation !== void 0 ? _props_useLocation : context === null || context === void 0 ? void 0 : (_context_router2 = context.router) === null || _context_router2 === void 0 ? void 0 : _context_router2.useLocation;
    var _props_useHistory;
    const useHistory = (_props_useHistory = props.useHistory) !== null && _props_useHistory !== void 0 ? _props_useHistory : context === null || context === void 0 ? void 0 : (_context_router3 = context.router) === null || _context_router3 === void 0 ? void 0 : _context_router3.useHistory;
    var _props_useHistory1;
    const useHref = (_props_useHistory1 = props.useHistory) !== null && _props_useHistory1 !== void 0 ? _props_useHistory1 : context === null || context === void 0 ? void 0 : (_context_router4 = context.router) === null || _context_router4 === void 0 ? void 0 : _context_router4.useHref;
    const match = useRouteMatch === null || useRouteMatch === void 0 ? void 0 : useRouteMatch();
    const matchs = useMatches === null || useMatches === void 0 ? void 0 : useMatches();
    if (!useLocation) {
      console.warn(`[@modern-js/plugin-garfish] Detected that the 'router: false' mode is used. In this case, the basename and popStateEvent cannot be correctly passed to the sub-app.
You can manually pass 'useLocation' and 'useHref' props to assist plugin-garfish in calculating the "basename" and sync popStateEvent:
if you are using react-router-V6:
<Component useLocation={useLocation} useHref={useHref} />

else react-router-V5:
<Component useLocation={useLocation} useHistory={useHistory} />

or directly pass the "basename":
<Component basename={basename} useLocation={useLocation} />`);
    }
    const location = useLocation();
    let basename = (options === null || options === void 0 ? void 0 : options.basename) || "/";
    if (useHistory) {
      var _history_createHref;
      const history = useHistory === null || useHistory === void 0 ? void 0 : useHistory();
      basename = history === null || history === void 0 ? void 0 : (_history_createHref = history.createHref) === null || _history_createHref === void 0 ? void 0 : _history_createHref.call(history, {
        pathname: "/"
      });
    } else if (useHref) {
      basename = useHref === null || useHref === void 0 ? void 0 : useHref("/");
    }
    if (matchs && matchs.length > 0) {
      const matchItem = {
        ...matchs[matchs.length - 1]
      };
      for (const key in matchItem.params) {
        matchItem.pathname = matchItem.pathname.replace(new RegExp(`/${matchItem.params[key]}$`), "");
      }
      basename = pathJoin(basename, matchItem.pathname || "/");
    } else if (match) {
      basename = pathJoin(basename, (match === null || match === void 0 ? void 0 : match.path) || "/");
    }
    if (props.basename && typeof props.basename === "string") {
      basename = props.basename;
    }
    (0, import_react.useEffect)(() => {
      if (location && locationHref !== location.pathname && !import_garfish.default.running) {
        locationHref = location.pathname;
        const popStateEvent = new PopStateEvent("popstate");
        popStateEvent.garfish = true;
        dispatchEvent(popStateEvent);
        (0, import_util.logger)(`MicroApp Garfish.loadApp popstate`);
      }
    }, [
      location
    ]);
    (0, import_react.useEffect)(() => {
      const { setLoadingState, ...userProps } = props;
      const loadAppOptions = {
        cache: true,
        insulationVariable: [
          ...appInfo.insulationVariable || [],
          "_SERVER_DATA"
        ],
        domGetter: `#${domId}`,
        ...appInfo,
        basename,
        props: {
          ...appInfo.props,
          ...userProps
        },
        customLoader: (provider) => {
          const { render, destroy, SubModuleComponent: SubModuleComponent2, jupiter_submodule_app_key } = provider;
          const componetRenderMode = (manifest === null || manifest === void 0 ? void 0 : manifest.componentRender) && (SubModuleComponent2 || jupiter_submodule_app_key);
          return {
            mount: (...props2) => {
              if (componetRenderMode) {
                setSubModuleComponent(SubModuleComponent2);
                return void 0;
              } else {
                (0, import_util.logger)("MicroApp customer render", props2);
                return render === null || render === void 0 ? void 0 : render.apply(provider, props2);
              }
            },
            unmount(...props2) {
              if (componetRenderMode) {
                return void 0;
              }
              (0, import_util.logger)("MicroApp customer destroy", props2);
              return destroy === null || destroy === void 0 ? void 0 : destroy.apply(provider, props2);
            }
          };
        }
      };
      setLoadingState({
        isLoading: true,
        error: null
      });
      (0, import_util.logger)(`MicroApp Garfish.loadApp "${appInfo.name}"`, {
        loadAppOptions
      });
      async function renderApp() {
        try {
          const appInstance = await import_garfish.default.loadApp(appInfo.name, loadAppOptions);
          if (!appInstance) {
            throw new Error(`MicroApp Garfish.loadApp "${appInfo.name}" result is null`);
          }
          appRef.current = appInstance;
          setLoadingState({
            isLoading: false
          });
          if (appInstance.mounted && appInstance.appInfo.cache) {
            (0, import_util.logger)(`MicroApp Garfish.loadApp "${appInfo.name}" show`, {
              appInfo: appInstance.appInfo,
              appInstance
            });
            await (appInstance === null || appInstance === void 0 ? void 0 : appInstance.show());
          } else {
            (0, import_util.logger)(`MicroApp Garfish.loadApp "${appInfo.name}" mount`, {
              appInfo: appInstance.appInfo,
              appInstance
            });
            await (appInstance === null || appInstance === void 0 ? void 0 : appInstance.mount());
          }
        } catch (error) {
          setLoadingState({
            isLoading: true,
            error
          });
        }
      }
      renderApp();
      return () => {
        if (appRef.current) {
          const { appInfo: appInfo2 } = appRef.current;
          if (appInfo2.cache) {
            var _appRef_current;
            (0, import_util.logger)(`MicroApp Garfish.loadApp "${appInfo2.name}" hide`);
            (_appRef_current = appRef.current) === null || _appRef_current === void 0 ? void 0 : _appRef_current.hide();
          } else {
            var _appRef_current1;
            (0, import_util.logger)(`MicroApp Garfish.loadApp "${appInfo2.name}" unmount`);
            (_appRef_current1 = appRef.current) === null || _appRef_current1 === void 0 ? void 0 : _appRef_current1.unmount();
          }
        }
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
        id: domId,
        children: SubModuleComponent && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SubModuleComponent, {})
      })
    });
  }
  return (0, import_loadable.Loadable)(MicroApp)(manifest === null || manifest === void 0 ? void 0 : manifest.loadable);
}
function generateApps(options, manifest) {
  var _options_apps;
  const apps = {};
  (_options_apps = options.apps) === null || _options_apps === void 0 ? void 0 : _options_apps.forEach((appInfo) => {
    const Component = getAppInstance(options, appInfo, manifest);
    appInfo.Component = Component;
    apps[appInfo.name] = Component;
  });
  return {
    apps,
    appInfoList: options.apps || []
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateApps,
  pathJoin
});
