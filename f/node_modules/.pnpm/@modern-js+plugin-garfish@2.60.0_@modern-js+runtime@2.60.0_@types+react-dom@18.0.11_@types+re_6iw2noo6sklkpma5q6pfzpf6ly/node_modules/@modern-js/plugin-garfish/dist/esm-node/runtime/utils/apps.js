import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { RuntimeReactContext } from "@meta/runtime";
import Garfish from "garfish";
import { useContext, useEffect, useRef, useState } from "react";
import { generateSubAppContainerKey, logger } from "../../util";
import { Loadable } from "../loadable";
function pathJoin(...args) {
  const res = args.reduce((res2, path) => {
    let nPath = path;
    if (!nPath || typeof nPath !== "string") {
      return res2;
    }
    if (nPath[0] !== "/") {
      nPath = `/${nPath}`;
    }
    const lastIndex = nPath.length - 1;
    if (nPath[lastIndex] === "/") {
      nPath = nPath.substring(0, lastIndex);
    }
    return res2 + nPath;
  }, "");
  return res || "/";
}
function getAppInstance(options, appInfo, manifest) {
  let locationHref = "";
  function MicroApp(props) {
    var _context_router, _context_router1, _context_router2, _context_router3, _context_router4;
    const appRef = useRef(null);
    const domId = generateSubAppContainerKey(appInfo);
    const [SubModuleComponent, setSubModuleComponent] = useState();
    const context = useContext(RuntimeReactContext);
    var _props_useRouteMatch;
    const useRouteMatch = (_props_useRouteMatch = props.useRouteMatch) !== null && _props_useRouteMatch !== void 0 ? _props_useRouteMatch : context === null || context === void 0 ? void 0 : (_context_router = context.router) === null || _context_router === void 0 ? void 0 : _context_router.useRouteMatch;
    var _props_useMatches;
    const useMatches = (_props_useMatches = props.useMatches) !== null && _props_useMatches !== void 0 ? _props_useMatches : context === null || context === void 0 ? void 0 : (_context_router1 = context.router) === null || _context_router1 === void 0 ? void 0 : _context_router1.useMatches;
    var _props_useLocation;
    const useLocation = (_props_useLocation = props.useLocation) !== null && _props_useLocation !== void 0 ? _props_useLocation : context === null || context === void 0 ? void 0 : (_context_router2 = context.router) === null || _context_router2 === void 0 ? void 0 : _context_router2.useLocation;
    var _props_useHistory;
    const useHistory = (_props_useHistory = props.useHistory) !== null && _props_useHistory !== void 0 ? _props_useHistory : context === null || context === void 0 ? void 0 : (_context_router3 = context.router) === null || _context_router3 === void 0 ? void 0 : _context_router3.useHistory;
    var _props_useHistory1;
    const useHref = (_props_useHistory1 = props.useHistory) !== null && _props_useHistory1 !== void 0 ? _props_useHistory1 : context === null || context === void 0 ? void 0 : (_context_router4 = context.router) === null || _context_router4 === void 0 ? void 0 : _context_router4.useHref;
    const match = useRouteMatch === null || useRouteMatch === void 0 ? void 0 : useRouteMatch();
    const matchs = useMatches === null || useMatches === void 0 ? void 0 : useMatches();
    if (!useLocation) {
      console.warn(`[@modern-js/plugin-garfish] Detected that the 'router: false' mode is used. In this case, the basename and popStateEvent cannot be correctly passed to the sub-app.
You can manually pass 'useLocation' and 'useHref' props to assist plugin-garfish in calculating the "basename" and sync popStateEvent:
if you are using react-router-V6:
<Component useLocation={useLocation} useHref={useHref} />

else react-router-V5:
<Component useLocation={useLocation} useHistory={useHistory} />

or directly pass the "basename":
<Component basename={basename} useLocation={useLocation} />`);
    }
    const location = useLocation();
    let basename = (options === null || options === void 0 ? void 0 : options.basename) || "/";
    if (useHistory) {
      var _history_createHref;
      const history = useHistory === null || useHistory === void 0 ? void 0 : useHistory();
      basename = history === null || history === void 0 ? void 0 : (_history_createHref = history.createHref) === null || _history_createHref === void 0 ? void 0 : _history_createHref.call(history, {
        pathname: "/"
      });
    } else if (useHref) {
      basename = useHref === null || useHref === void 0 ? void 0 : useHref("/");
    }
    if (matchs && matchs.length > 0) {
      const matchItem = {
        ...matchs[matchs.length - 1]
      };
      for (const key in matchItem.params) {
        matchItem.pathname = matchItem.pathname.replace(new RegExp(`/${matchItem.params[key]}$`), "");
      }
      basename = pathJoin(basename, matchItem.pathname || "/");
    } else if (match) {
      basename = pathJoin(basename, (match === null || match === void 0 ? void 0 : match.path) || "/");
    }
    if (props.basename && typeof props.basename === "string") {
      basename = props.basename;
    }
    useEffect(() => {
      if (location && locationHref !== location.pathname && !Garfish.running) {
        locationHref = location.pathname;
        const popStateEvent = new PopStateEvent("popstate");
        popStateEvent.garfish = true;
        dispatchEvent(popStateEvent);
        logger(`MicroApp Garfish.loadApp popstate`);
      }
    }, [
      location
    ]);
    useEffect(() => {
      const { setLoadingState, ...userProps } = props;
      const loadAppOptions = {
        cache: true,
        insulationVariable: [
          ...appInfo.insulationVariable || [],
          "_SERVER_DATA"
        ],
        domGetter: `#${domId}`,
        ...appInfo,
        basename,
        props: {
          ...appInfo.props,
          ...userProps
        },
        customLoader: (provider) => {
          const { render, destroy, SubModuleComponent: SubModuleComponent2, jupiter_submodule_app_key } = provider;
          const componetRenderMode = (manifest === null || manifest === void 0 ? void 0 : manifest.componentRender) && (SubModuleComponent2 || jupiter_submodule_app_key);
          return {
            mount: (...props2) => {
              if (componetRenderMode) {
                setSubModuleComponent(SubModuleComponent2);
                return void 0;
              } else {
                logger("MicroApp customer render", props2);
                return render === null || render === void 0 ? void 0 : render.apply(provider, props2);
              }
            },
            unmount(...props2) {
              if (componetRenderMode) {
                return void 0;
              }
              logger("MicroApp customer destroy", props2);
              return destroy === null || destroy === void 0 ? void 0 : destroy.apply(provider, props2);
            }
          };
        }
      };
      setLoadingState({
        isLoading: true,
        error: null
      });
      logger(`MicroApp Garfish.loadApp "${appInfo.name}"`, {
        loadAppOptions
      });
      async function renderApp() {
        try {
          const appInstance = await Garfish.loadApp(appInfo.name, loadAppOptions);
          if (!appInstance) {
            throw new Error(`MicroApp Garfish.loadApp "${appInfo.name}" result is null`);
          }
          appRef.current = appInstance;
          setLoadingState({
            isLoading: false
          });
          if (appInstance.mounted && appInstance.appInfo.cache) {
            logger(`MicroApp Garfish.loadApp "${appInfo.name}" show`, {
              appInfo: appInstance.appInfo,
              appInstance
            });
            await (appInstance === null || appInstance === void 0 ? void 0 : appInstance.show());
          } else {
            logger(`MicroApp Garfish.loadApp "${appInfo.name}" mount`, {
              appInfo: appInstance.appInfo,
              appInstance
            });
            await (appInstance === null || appInstance === void 0 ? void 0 : appInstance.mount());
          }
        } catch (error) {
          setLoadingState({
            isLoading: true,
            error
          });
        }
      }
      renderApp();
      return () => {
        if (appRef.current) {
          const { appInfo: appInfo2 } = appRef.current;
          if (appInfo2.cache) {
            var _appRef_current;
            logger(`MicroApp Garfish.loadApp "${appInfo2.name}" hide`);
            (_appRef_current = appRef.current) === null || _appRef_current === void 0 ? void 0 : _appRef_current.hide();
          } else {
            var _appRef_current1;
            logger(`MicroApp Garfish.loadApp "${appInfo2.name}" unmount`);
            (_appRef_current1 = appRef.current) === null || _appRef_current1 === void 0 ? void 0 : _appRef_current1.unmount();
          }
        }
      };
    }, []);
    return /* @__PURE__ */ _jsx(_Fragment, {
      children: /* @__PURE__ */ _jsx("div", {
        id: domId,
        children: SubModuleComponent && /* @__PURE__ */ _jsx(SubModuleComponent, {})
      })
    });
  }
  return Loadable(MicroApp)(manifest === null || manifest === void 0 ? void 0 : manifest.loadable);
}
function generateApps(options, manifest) {
  var _options_apps;
  const apps = {};
  (_options_apps = options.apps) === null || _options_apps === void 0 ? void 0 : _options_apps.forEach((appInfo) => {
    const Component = getAppInstance(options, appInfo, manifest);
    appInfo.Component = Component;
    apps[appInfo.name] = Component;
  });
  return {
    apps,
    appInfoList: options.apps || []
  };
}
export {
  generateApps,
  pathJoin
};
