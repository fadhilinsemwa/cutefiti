import { _ as _async_to_generator } from "@swc/helpers/_/_async_to_generator";
import { _ as _ts_generator } from "@swc/helpers/_/_ts_generator";
import path from "path";
import { fs } from "@modern-js/utils";
import * as template from "./template";
import { generateAsyncEntryCode } from "./utils";
var ENTRY_POINT_FILE_NAME = "index.jsx";
var ENTRY_BOOTSTRAP_FILE_NAME = "bootstrap.jsx";
var generateCode = function() {
  var _ref = _async_to_generator(function(entrypoints, appContext, config, appendEntryCode) {
    var mountId, enableAsyncEntry, internalDirectory, internalSrcAlias, metaName, srcDirectory;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          mountId = config.html.mountId;
          enableAsyncEntry = config.source.enableAsyncEntry;
          internalDirectory = appContext.internalDirectory, internalSrcAlias = appContext.internalSrcAlias, metaName = appContext.metaName, srcDirectory = appContext.srcDirectory;
          return [
            4,
            Promise.all(entrypoints.map(function() {
              var _ref2 = _async_to_generator(function(entrypoint) {
                var entryName, isAutoMount, entry, customEntry, customBootstrap, appendCode, indexCode, indexFile, bootstrapFile;
                return _ts_generator(this, function(_state2) {
                  switch (_state2.label) {
                    case 0:
                      entryName = entrypoint.entryName, isAutoMount = entrypoint.isAutoMount, entry = entrypoint.entry, customEntry = entrypoint.customEntry, customBootstrap = entrypoint.customBootstrap;
                      return [
                        4,
                        appendEntryCode({
                          entrypoint
                        })
                      ];
                    case 1:
                      appendCode = _state2.sent();
                      if (isAutoMount) {
                        indexCode = template.index({
                          srcDirectory,
                          internalSrcAlias,
                          metaName,
                          entry,
                          entryName,
                          customEntry,
                          customBootstrap,
                          mountId,
                          appendCode
                        });
                        indexFile = path.resolve(internalDirectory, "./".concat(entryName, "/").concat(ENTRY_POINT_FILE_NAME));
                        fs.outputFileSync(indexFile, indexCode, "utf8");
                        if (enableAsyncEntry) {
                          bootstrapFile = path.resolve(internalDirectory, "./".concat(entryName, "/").concat(ENTRY_BOOTSTRAP_FILE_NAME));
                          fs.outputFileSync(bootstrapFile, generateAsyncEntryCode(appendCode), "utf8");
                        }
                      }
                      return [
                        2
                      ];
                  }
                });
              });
              return function(entrypoint) {
                return _ref2.apply(this, arguments);
              };
            }()))
          ];
        case 1:
          _state.sent();
          return [
            2
          ];
      }
    });
  });
  return function generateCode2(entrypoints, appContext, config, appendEntryCode) {
    return _ref.apply(this, arguments);
  };
}();
export {
  ENTRY_BOOTSTRAP_FILE_NAME,
  generateCode
};
