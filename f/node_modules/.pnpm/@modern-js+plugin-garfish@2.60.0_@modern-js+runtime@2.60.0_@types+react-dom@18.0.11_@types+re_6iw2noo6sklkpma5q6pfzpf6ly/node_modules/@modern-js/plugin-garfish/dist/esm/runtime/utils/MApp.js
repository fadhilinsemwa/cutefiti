import { _ as _call_super } from "@swc/helpers/_/_call_super";
import { _ as _class_call_check } from "@swc/helpers/_/_class_call_check";
import { _ as _inherits } from "@swc/helpers/_/_inherits";
import { _ as _object_spread } from "@swc/helpers/_/_object_spread";
import { _ as _object_without_properties } from "@swc/helpers/_/_object_without_properties";
import { _ as _to_consumable_array } from "@swc/helpers/_/_to_consumable_array";
import { jsx as _jsx } from "react/jsx-runtime";
import Garfish from "garfish";
import React from "react";
import { generateSubAppContainerKey, logger } from "../../util";
import { Loadable } from "../loadable";
function generateMApp(options, manifest) {
  var MApp = /* @__PURE__ */ function(_React_Component) {
    "use strict";
    _inherits(MApp2, _React_Component);
    function MApp2() {
      _class_call_check(this, MApp2);
      var _this;
      _this = _call_super(this, MApp2, arguments), _this.state = {
        domId: generateSubAppContainerKey()
      };
      return _this;
    }
    var _proto = MApp2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      var _this = this;
      var domId = this.state.domId;
      var setLoadingState = this.props.setLoadingState;
      var beforeLoad = options.beforeLoad, beforeMount = options.beforeMount, errorLoadApp = options.errorLoadApp, errorMountApp = options.errorMountApp, errorUnmountApp = options.errorUnmountApp;
      Garfish.router.setRouterConfig({
        listening: true
      });
      var garfishOptions = {
        domGetter: "#".concat(domId),
        beforeLoad: function beforeLoad1(appInfo) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          logger("MApp beforeLoad", [
            appInfo
          ]);
          if (appInfo.activeWhen) {
            setLoadingState({
              isLoading: true,
              error: null
            });
          }
          return beforeLoad === null || beforeLoad === void 0 ? void 0 : beforeLoad.apply(void 0, [
            appInfo
          ].concat(_to_consumable_array(args)));
        },
        beforeMount: function beforeMount1(appInfo) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          logger("MApp beforeMount", args);
          if (appInfo.activeWhen) {
            setLoadingState({
              isLoading: false
            });
          }
          return beforeMount === null || beforeMount === void 0 ? void 0 : beforeMount.apply(void 0, [
            appInfo
          ].concat(_to_consumable_array(args)));
        },
        errorLoadApp: function errorLoadApp1(error, appInfo) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          logger("MApp errorLoadApp", error, args);
          if (appInfo.activeWhen) {
            setLoadingState({
              error
            });
          }
          return errorLoadApp === null || errorLoadApp === void 0 ? void 0 : errorLoadApp.apply(void 0, [
            error,
            appInfo
          ].concat(_to_consumable_array(args)));
        },
        errorMountApp: function errorMountApp1(error, appInfo) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          logger("MApp errorMountApp", error, args);
          if (appInfo.activeWhen) {
            setLoadingState({
              error
            });
          }
          return errorMountApp === null || errorMountApp === void 0 ? void 0 : errorMountApp.apply(void 0, [
            error,
            appInfo
          ].concat(_to_consumable_array(args)));
        },
        errorUnmountApp: function errorUnmountApp1(error, appInfo) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          logger("MApp errorUnmountApp", error, args);
          if (appInfo.activeWhen) {
            setLoadingState({
              error
            });
          }
          return errorUnmountApp === null || errorUnmountApp === void 0 ? void 0 : errorUnmountApp.apply(void 0, [
            error,
            appInfo
          ].concat(_to_consumable_array(args)));
        },
        customLoader: function(provider) {
          var render = provider.render, destroy = provider.destroy, SubModuleComponent = provider.SubModuleComponent, jupiter_submodule_app_key = provider.jupiter_submodule_app_key;
          var componetRenderMode = (manifest === null || manifest === void 0 ? void 0 : manifest.componentRender) && (SubModuleComponent || jupiter_submodule_app_key);
          return {
            mount: function(appInfo) {
              var transferProps = _this.filterTransferProps();
              appInfo.props = _object_spread({}, appInfo.props, transferProps);
              if (componetRenderMode) {
                _this.setState({
                  SubModuleComponent: SubModuleComponent !== null && SubModuleComponent !== void 0 ? SubModuleComponent : jupiter_submodule_app_key
                });
                return void 0;
              } else {
                logger("MicroApp customer render", appInfo);
                return render === null || render === void 0 ? void 0 : render.apply(provider, [
                  appInfo
                ]);
              }
            },
            unmount: function(appInfo) {
              var transferProps = _this.filterTransferProps();
              appInfo.props = _object_spread({}, appInfo.props, transferProps);
              if (componetRenderMode) {
                return void 0;
              }
              logger("MicroApp customer destroy", appInfo);
              return destroy === null || destroy === void 0 ? void 0 : destroy.apply(provider, [
                appInfo
              ]);
            }
          };
        }
      };
      logger("MApp componentDidMount", {
        garfishRunning: Garfish.running,
        garfishOptions
      });
      if (!Garfish.running) {
        Garfish.run(garfishOptions);
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      Garfish.router.setRouterConfig({
        listening: false
      });
      logger("MApp componentWillUnmount");
    };
    _proto.filterTransferProps = function filterTransferProps() {
      var _this_props = this.props, style = _this_props.style, setLoadingState = _this_props.setLoadingState, others = _object_without_properties(_this_props, [
        "style",
        "setLoadingState"
      ]);
      return others;
    };
    _proto.render = function render() {
      var style = this.props.style;
      var SubModuleComponent = this.state.SubModuleComponent;
      return /* @__PURE__ */ _jsx("div", {
        style: _object_spread({}, style),
        id: generateSubAppContainerKey(),
        children: SubModuleComponent && /* @__PURE__ */ _jsx(SubModuleComponent, {})
      });
    };
    return MApp2;
  }(React.Component);
  return Loadable(MApp)(manifest === null || manifest === void 0 ? void 0 : manifest.loadable);
}
export {
  generateMApp
};
