"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var nestedRoutes_exports = {};
__export(nestedRoutes_exports, {
  renderNestedRoute: () => renderNestedRoute,
  transformNestedRoutes: () => transformNestedRoutes
});
module.exports = __toCommonJS(nestedRoutes_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_constants = require("@modern-js/utils/universal/constants");
var import_react = require("react");
var import_react_router_dom = require("react-router-dom");
var import_time = require("../time");
const transformNestedRoutes = (routes, reporter) => {
  const routeElements = [];
  for (const route of routes) {
    const routeElement = renderNestedRoute(route, {
      reporter
    });
    routeElements.push(routeElement);
  }
  return (0, import_react_router_dom.createRoutesFromElements)(routeElements);
};
const renderNestedRoute = (nestedRoute, options = {}) => {
  const { children, index, id, component, isRoot, lazyImport, config, handle } = nestedRoute;
  const Component = component;
  const { parent, props = {}, reporter } = options;
  const routeProps = {
    caseSensitive: nestedRoute.caseSensitive,
    path: nestedRoute.path,
    id: nestedRoute.id,
    loader: createLoader(nestedRoute, reporter),
    action: nestedRoute.action,
    hasErrorBoundary: nestedRoute.hasErrorBoundary,
    shouldRevalidate: nestedRoute.shouldRevalidate,
    handle: {
      ...handle,
      ...typeof config === "object" ? config === null || config === void 0 ? void 0 : config.handle : {}
    },
    index: nestedRoute.index,
    element: nestedRoute.element,
    errorElement: nestedRoute.errorElement
  };
  if (nestedRoute.error) {
    const errorElement = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(nestedRoute.error, {});
    routeProps.errorElement = errorElement;
  }
  let element;
  if (Component) {
    if ((parent === null || parent === void 0 ? void 0 : parent.loading) && lazyImport) {
      const Loading = parent.loading;
      if (isLoadableComponent(Component)) {
        element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
          fallback: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loading, {})
        });
      } else {
        element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Suspense, {
          fallback: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Loading, {}),
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {})
        });
      }
    } else if (isLoadableComponent(Component) && lazyImport) {
      element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {});
    } else if (isRoot) {
      element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {
          ...props
        })
      });
    } else if (lazyImport) {
      element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Suspense, {
        fallback: null,
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {})
      });
    } else {
      element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, {});
    }
  } else {
    nestedRoute.loading = parent === null || parent === void 0 ? void 0 : parent.loading;
    routeProps.element = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react_router_dom.Outlet, {});
  }
  if (element) {
    routeProps.element = element;
  }
  const childElements = children === null || children === void 0 ? void 0 : children.map((childRoute) => {
    return renderNestedRoute(childRoute, {
      parent: nestedRoute,
      reporter
    });
  });
  const routeElement = index ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react_router_dom.Route, {
    ...routeProps,
    index: true
  }, id) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react_router_dom.Route, {
    ...routeProps,
    index: false,
    children: childElements
  }, id);
  return routeElement;
};
function createLoader(route, reporter) {
  const { loader } = route;
  if (loader) {
    return async (args) => {
      if (typeof route.lazyImport === "function") {
        route.lazyImport();
      }
      const end = (0, import_time.time)();
      const res = await loader(args);
      const cost = end();
      if (typeof document === "undefined" && reporter) {
        reporter === null || reporter === void 0 ? void 0 : reporter.reportTiming(`${import_constants.LOADER_REPORTER_NAME}-${route.id}`, cost);
      }
      return res;
    };
  } else {
    return () => {
      if (typeof route.lazyImport === "function") {
        route.lazyImport();
      }
      return null;
    };
  }
}
function isLoadableComponent(component) {
  return component && component.displayName === "Loadable" && component.preload && typeof component.preload === "function";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  renderNestedRoute,
  transformNestedRoutes
});
