"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_exports = {};
__export(plugin_exports, {
  beforeCreateRouter: () => beforeCreateRouter,
  finalRouteConfig: () => finalRouteConfig,
  modifyRoutes: () => modifyRoutes,
  routerPlugin: () => routerPlugin
});
module.exports = __toCommonJS(plugin_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_merge = require("@modern-js/runtime-utils/merge");
var import_parsed = require("@modern-js/runtime-utils/parsed");
var import_router = require("@modern-js/runtime-utils/router");
var import_react = require("react");
var import_core = require("../../core");
var import_context = require("../../core/context");
var import_hooks = require("./hooks");
var import_utils = require("./utils");
let finalRouteConfig = {
  routes: []
};
let beforeCreateRouter = true;
function modifyRoutes(modifyFunction) {
  if (beforeCreateRouter) {
    const { routes: originRoutes } = finalRouteConfig;
    const newRoutes = modifyFunction(originRoutes);
    finalRouteConfig.routes = newRoutes;
  } else {
    console.error("It is not allowed to modify routes config after create router.");
  }
}
const routerPlugin = (userConfig = {}) => {
  return {
    name: "@modern-js/plugin-router",
    registerHook: {
      modifyRoutes: import_hooks.modifyRoutes
    },
    setup: (api) => {
      let routes = [];
      window._SERVER_DATA = (0, import_parsed.parsedJSONFromElement)("__MODERN_SERVER_DATA__");
      return {
        beforeRender(context) {
          context.router = {
            useMatches: import_router.useMatches,
            useLocation: import_router.useLocation,
            useHref: import_router.useHref
          };
          Object.defineProperty(context, "routes", {
            get() {
              return routes;
            }
          });
        },
        wrapRoot: (App) => {
          const pluginConfig = api.useRuntimeConfigContext();
          const { serverBase = [], supportHtml5History = true, basename = "", routesConfig, createRoutes } = (0, import_merge.merge)(pluginConfig.router || {}, userConfig);
          const select = (pathname) => serverBase.find((baseUrl) => pathname.search(baseUrl) === 0) || "/";
          finalRouteConfig = {
            routes: (0, import_context.getGlobalRoutes)(),
            globalApp: (0, import_context.getGlobalLayoutApp)(),
            ...routesConfig
          };
          if (!finalRouteConfig.routes && !createRoutes) {
            return App;
          }
          const getRouteApp = () => {
            const useCreateRouter = (props) => {
              var _window__SERVER_DATA;
              const runtimeContext = (0, import_react.useContext)(import_core.RuntimeReactContext);
              const baseUrl = (runtimeContext._internalRouterBaseName || ((_window__SERVER_DATA = window._SERVER_DATA) === null || _window__SERVER_DATA === void 0 ? void 0 : _window__SERVER_DATA.router.baseUrl) || select(location.pathname)).replace(/^\/*/, "/");
              const _basename = baseUrl === "/" ? (0, import_utils.urlJoin)(baseUrl, basename) : baseUrl;
              let hydrationData = window._ROUTER_DATA;
              const { unstable_getBlockNavState: getBlockNavState } = runtimeContext;
              return (0, import_react.useMemo)(() => {
                if (hydrationData === null || hydrationData === void 0 ? void 0 : hydrationData.errors) {
                  hydrationData = {
                    ...hydrationData,
                    errors: (0, import_utils.deserializeErrors)(hydrationData.errors)
                  };
                }
                routes = createRoutes ? createRoutes() : (0, import_router.createRoutesFromElements)((0, import_utils.renderRoutes)({
                  routesConfig: finalRouteConfig,
                  props
                }));
                const runner = api.useHookRunners();
                routes = runner.modifyRoutes(routes);
                const router = supportHtml5History ? (0, import_router.createBrowserRouter)(routes, {
                  basename: _basename,
                  hydrationData
                }) : (0, import_router.createHashRouter)(routes, {
                  basename: _basename,
                  hydrationData
                });
                const originSubscribe = router.subscribe;
                router.subscribe = (listener) => {
                  const wrapedListener = (...args) => {
                    const blockRoute = getBlockNavState ? getBlockNavState() : false;
                    if (blockRoute) {
                      return;
                    }
                    return listener(...args);
                  };
                  return originSubscribe(wrapedListener);
                };
                Object.defineProperty(runtimeContext, "remixRouter", {
                  get() {
                    return router;
                  },
                  configurable: true,
                  enumerable: true
                });
                return router;
              }, [
                finalRouteConfig,
                props,
                _basename,
                hydrationData,
                getBlockNavState
              ]);
            };
            const Null = () => null;
            return (props) => {
              beforeCreateRouter = false;
              const router = useCreateRouter(props);
              return (
                // To match the node tree about https://github.com/web-infra-dev/modern.js/blob/v2.59.0/packages/runtime/plugin-runtime/src/router/runtime/plugin.node.tsx#L150-L168
                // According to react [useId generation algorithm](https://github.com/facebook/react/pull/22644), `useId` will generate id with the react node react struct.
                // To void hydration failed, we must guarantee that the node tree when browser hydrate must have same struct with node tree when ssr render.
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_router.RouterProvider, {
                      router
                    }),
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Null, {}),
                    /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Null, {})
                  ]
                })
              );
            };
          };
          return getRouteApp();
        },
        pickContext: (pickedContext) => {
          const { remixRouter } = pickedContext;
          if (!remixRouter) {
            return pickedContext;
          }
          const router = {
            ...pickedContext.router,
            navigate: remixRouter.navigate,
            get location() {
              return remixRouter.state.location;
            }
          };
          return {
            ...pickedContext,
            router
          };
        }
      };
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  beforeCreateRouter,
  finalRouteConfig,
  modifyRoutes,
  routerPlugin
});
