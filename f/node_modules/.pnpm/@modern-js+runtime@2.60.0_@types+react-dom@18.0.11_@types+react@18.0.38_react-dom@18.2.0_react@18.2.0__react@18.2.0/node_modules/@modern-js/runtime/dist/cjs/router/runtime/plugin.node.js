"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_node_exports = {};
__export(plugin_node_exports, {
  modifyRoutes: () => modifyRoutes,
  routerPlugin: () => routerPlugin
});
module.exports = __toCommonJS(plugin_node_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_merge = require("@modern-js/runtime-utils/merge");
var import_node = require("@modern-js/runtime-utils/node");
var import_router = require("@modern-js/runtime-utils/node/router");
var import_remix_router = require("@modern-js/runtime-utils/remix-router");
var import_router2 = require("@modern-js/runtime-utils/router");
var import_time = require("@modern-js/runtime-utils/time");
var import_constants = require("@modern-js/utils/universal/constants");
var import_react = require("react");
var import_common = require("../../common");
var import_core = require("../../core");
var import_context = require("../../core/context");
var import_DeferredDataScripts = __toESM(require("./DeferredDataScripts.node"));
var import_hooks = require("./hooks");
var import_utils = require("./utils");
function createRemixReuqest(request) {
  const method = "GET";
  const { headers } = request;
  const controller = new AbortController();
  return new Request(request.url, {
    method,
    headers,
    signal: controller.signal
  });
}
const routerPlugin = (userConfig = {}) => {
  return {
    name: "@modern-js/plugin-router",
    registerHook: {
      modifyRoutes: import_hooks.modifyRoutes
    },
    setup: (api) => {
      let finalRouteConfig = {};
      return {
        async beforeRender(context, interrupt) {
          var _context_ssrContext, _context_ssrContext_onTiming, _context_ssrContext1;
          const pluginConfig = api.useRuntimeConfigContext();
          const { basename = "", routesConfig, createRoutes } = (0, import_merge.merge)(pluginConfig.router || {}, userConfig);
          finalRouteConfig = {
            routes: (0, import_context.getGlobalRoutes)(),
            globalApp: (0, import_context.getGlobalLayoutApp)(),
            ...routesConfig
          };
          if (!finalRouteConfig.routes && !createRoutes) {
            return;
          }
          const { request, mode: ssrMode, nonce, loaderFailureMode = "errorBoundary" } = context.ssrContext;
          const { baseUrl } = request;
          const _basename = baseUrl === "/" ? (0, import_utils.urlJoin)(baseUrl, basename) : baseUrl;
          const { reporter } = context.ssrContext;
          const requestContext = (0, import_node.createRequestContext)((_context_ssrContext = context.ssrContext) === null || _context_ssrContext === void 0 ? void 0 : _context_ssrContext.loaderContext);
          requestContext.set(import_node.reporterCtx, reporter);
          let routes = createRoutes ? createRoutes() : (0, import_router2.createRoutesFromElements)((0, import_utils.renderRoutes)({
            routesConfig: finalRouteConfig,
            ssrMode,
            props: {
              nonce
            },
            reporter
          }));
          const runner = api.useHookRunners();
          routes = runner.modifyRoutes(routes);
          const { query } = (0, import_remix_router.createStaticHandler)(routes, {
            basename: _basename
          });
          const remixRequest = createRemixReuqest(context.ssrContext.request.raw);
          const end = (0, import_time.time)();
          const routerContext = await query(remixRequest, {
            requestContext
          });
          const cost = end();
          (_context_ssrContext1 = context.ssrContext) === null || _context_ssrContext1 === void 0 ? void 0 : (_context_ssrContext_onTiming = _context_ssrContext1.onTiming) === null || _context_ssrContext_onTiming === void 0 ? void 0 : _context_ssrContext_onTiming.call(_context_ssrContext1, import_constants.LOADER_REPORTER_NAME, cost);
          if (routerContext instanceof Response) {
            return interrupt(routerContext);
          }
          if (routerContext.statusCode >= 500 && routerContext.statusCode < 600 && loaderFailureMode === "clientRender") {
            routerContext.statusCode = 200;
            throw routerContext.errors[0];
          }
          const router = (0, import_router.createStaticRouter)(routes, routerContext);
          context.remixRouter = router;
          context.routerContext = routerContext;
          context.routes = routes;
        },
        wrapRoot: (App) => {
          if (!finalRouteConfig) {
            return App;
          }
          const getRouteApp = () => {
            return () => {
              const context = (0, import_react.useContext)(import_core.RuntimeReactContext);
              const { remixRouter, routerContext, ssrContext } = context;
              const { nonce, mode } = ssrContext;
              return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_router.StaticRouterProvider, {
                    router: remixRouter,
                    context: routerContext,
                    hydrate: false
                  }),
                  mode === "stream" && // ROUTER_DATA will inject in `packages/runtime/plugin-runtime/src/core/server/string/ssrData.ts` in string ssr
                  // So we can inject it only when streaming ssr
                  /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_DeferredDataScripts.default, {
                    nonce,
                    context: routerContext
                  }),
                  mode === "stream" && import_common.JSX_SHELL_STREAM_END_MARK
                ]
              });
            };
          };
          return getRouteApp();
        },
        pickContext: (pickedContext) => {
          const { remixRouter } = pickedContext;
          if (!remixRouter) {
            return pickedContext;
          }
          const router = {
            navigate: remixRouter.navigate,
            get location() {
              return remixRouter.state.location;
            }
          };
          return {
            ...pickedContext,
            router
          };
        }
      };
    }
  };
};
const modifyRoutes = () => {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  modifyRoutes,
  routerPlugin
});
