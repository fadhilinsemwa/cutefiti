import path from "path";
import { fs, filterRoutesForServer, filterRoutesLoader, getEntryOptions, isRouterV5, isSSGEntry, isUseSSRBundle, logger } from "@modern-js/utils";
import { cloneDeep } from "@modern-js/utils/lodash";
import { ENTRY_POINT_RUNTIME_GLOBAL_CONTEXT_FILE_NAME } from "../../../cli/constants";
import { FILE_SYSTEM_ROUTES_FILE_NAME } from "../constants";
import { getClientRoutes, getClientRoutesLegacy } from "./getClientRoutes";
import { walk } from "./nestedRoutes";
import * as templates from "./templates";
import { getServerCombinedModueFile, getServerLoadersFile } from "./utils";
const generateCode = async (appContext, config, entrypoints, api) => {
  const { internalDirectory, srcDirectory, internalDirAlias, internalSrcAlias, packageName } = appContext;
  const hookRunners = api.useHookRunners();
  const isV5 = isRouterV5(config);
  const getRoutes = isV5 ? getClientRoutesLegacy : getClientRoutes;
  const oldVersion = typeof (config === null || config === void 0 ? void 0 : config.runtime.router) === "object" ? Boolean((config === null || config === void 0 ? void 0 : config.runtime.router).oldVersion) : false;
  await Promise.all(entrypoints.map(generateEntryCode));
  async function generateEntryCode(entrypoint) {
    const { entryName, isMainEntry, isAutoMount, pageRoutesEntry, nestedRoutesEntry } = entrypoint;
    const { metaName } = api.useAppContext();
    if (isAutoMount) {
      if (pageRoutesEntry || nestedRoutesEntry) {
        var _config_output;
        let initialRoutes = [];
        let nestedRoutes = null;
        if (entrypoint.entry) {
          initialRoutes = getRoutes({
            entrypoint,
            srcDirectory,
            srcAlias: internalSrcAlias,
            internalDirectory,
            internalDirAlias
          });
        }
        if (!isV5 && entrypoint.nestedRoutesEntry) {
          nestedRoutes = await walk(entrypoint.nestedRoutesEntry, entrypoint.nestedRoutesEntry, {
            name: internalSrcAlias,
            basename: srcDirectory
          }, entrypoint.entryName, entrypoint.isMainEntry, oldVersion);
          if (nestedRoutes) {
            if (!Array.isArray(nestedRoutes)) {
              nestedRoutes = [
                nestedRoutes
              ];
            }
            for (const route of nestedRoutes) {
              initialRoutes.unshift(route);
            }
          }
        }
        const config2 = api.useResolvedConfigContext();
        const ssrByRouteIds = config2.server.ssrByRouteIds || [];
        const clonedRoutes = cloneDeep(initialRoutes);
        const markedRoutes = ssrByRouteIds.length > 0 ? markRoutes(clonedRoutes, ssrByRouteIds) : initialRoutes;
        const { routes } = await hookRunners.modifyFileSystemRoutes({
          entrypoint,
          routes: markedRoutes
        });
        const ssr = getEntryOptions(entryName, isMainEntry, config2.server.ssr, config2.server.ssrByEntries, packageName);
        const useSSG = isSSGEntry(config2, entryName, entrypoints);
        let mode;
        if (ssr) {
          mode = typeof ssr === "object" ? ssr.mode || "string" : "string";
        }
        if (mode === "stream") {
          const hasPageRoute = routes.some((route) => "type" in route && route.type === "page");
          if (hasPageRoute) {
            logger.error("Streaming ssr is not supported when pages dir exists");
            process.exit(1);
          }
        }
        const { code } = await hookRunners.beforeGenerateRoutes({
          entrypoint,
          code: await templates.fileSystemRoutes({
            metaName,
            routes,
            ssrMode: useSSG ? "string" : mode,
            nestedRoutesEntry: entrypoint.nestedRoutesEntry,
            entryName: entrypoint.entryName,
            internalDirectory,
            splitRouteChunks: config2 === null || config2 === void 0 ? void 0 : (_config_output = config2.output) === null || _config_output === void 0 ? void 0 : _config_output.splitRouteChunks
          })
        });
        if (entrypoint.nestedRoutesEntry && isUseSSRBundle(config2)) {
          var _config_output1;
          const routesServerFile = getServerLoadersFile(internalDirectory, entryName);
          const filtedRoutesForServer = filterRoutesForServer(routes);
          const routesForServerLoaderMatches = filterRoutesLoader(routes);
          const code2 = templates.routesForServer({
            routesForServerLoaderMatches
          });
          await fs.ensureFile(routesServerFile);
          await fs.writeFile(routesServerFile, code2);
          const serverRoutesCode = await templates.fileSystemRoutes({
            metaName,
            routes: filtedRoutesForServer,
            ssrMode: useSSG ? "string" : mode,
            nestedRoutesEntry: entrypoint.nestedRoutesEntry,
            entryName: entrypoint.entryName,
            internalDirectory,
            splitRouteChunks: config2 === null || config2 === void 0 ? void 0 : (_config_output1 = config2.output) === null || _config_output1 === void 0 ? void 0 : _config_output1.splitRouteChunks
          });
          await fs.outputFile(path.resolve(internalDirectory, `./${entryName}/routes.server.js`), serverRoutesCode, "utf8");
        }
        const serverLoaderCombined = templates.ssrLoaderCombinedModule(entrypoints, entrypoint, config2, appContext);
        if (serverLoaderCombined) {
          const serverLoaderFile = getServerCombinedModueFile(internalDirectory, entryName);
          await fs.outputFile(serverLoaderFile, serverLoaderCombined);
        }
        await fs.outputFile(path.resolve(internalDirectory, `./${entryName}/${FILE_SYSTEM_ROUTES_FILE_NAME}`), code, "utf8");
      }
    }
  }
};
function markRoutes(routes, routeIds) {
  return routes.map((route) => {
    if (route.type !== "nested") {
      return route;
    }
    if (route.children && route.children.length > 0) {
      route.children = markRoutes(route.children, routeIds);
    }
    if (route.children && route.children.length > 0) {
      route.inValidSSRRoute = route.children.every((child) => {
        var _child_inValidSSRRoute;
        return (_child_inValidSSRRoute = child.inValidSSRRoute) !== null && _child_inValidSSRRoute !== void 0 ? _child_inValidSSRRoute : false;
      });
    } else if (route.id) {
      route.inValidSSRRoute = !routeIds.includes(route.id);
    }
    return route;
  });
}
function generatorRegisterCode(internalDirectory, entryName, code) {
  fs.outputFileSync(path.resolve(internalDirectory, `./${entryName}/${ENTRY_POINT_RUNTIME_GLOBAL_CONTEXT_FILE_NAME}`), code, "utf8");
}
export {
  generateCode,
  generatorRegisterCode
};
