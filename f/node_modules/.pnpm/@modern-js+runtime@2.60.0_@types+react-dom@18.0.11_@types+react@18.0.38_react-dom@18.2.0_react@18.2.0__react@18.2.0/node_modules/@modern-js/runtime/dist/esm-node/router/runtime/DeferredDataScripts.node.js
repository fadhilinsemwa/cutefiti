import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { serializeJson } from "@modern-js/runtime-utils/node";
import { Await, useAsyncError } from "@modern-js/runtime-utils/router";
import { Suspense, useEffect, useMemo, useRef } from "react";
import { serializeErrors } from "./utils";
const setupFnStr = `function s(r,e){_ROUTER_DATA.r=_ROUTER_DATA.r||{},_ROUTER_DATA.r[r]=_ROUTER_DATA.r[r]||{};return new Promise((function(A,R){_ROUTER_DATA.r[r][e]={resolve:A,reject:R}}))};`;
const resolveFnStr = `function r(e,r,o,A){A?_ROUTER_DATA.r[e][r].reject(A):_ROUTER_DATA.r[e][r].resolve(o)};`;
const preResolvedFnStr = `function p(e,r){return void 0!==r?Promise.reject(new Error(r.message)):Promise.resolve(e)};`;
const DeferredDataScripts = (props) => {
  const staticContext = props === null || props === void 0 ? void 0 : props.context;
  const hydratedRef = useRef(false);
  useEffect(() => {
    hydratedRef.current = true;
  }, []);
  const deferredScripts = useMemo(() => {
    if (!staticContext) {
      return null;
    }
    const activeDeferreds = staticContext.activeDeferreds || [];
    const _ROUTER_DATA = {
      loaderData: staticContext.loaderData,
      errors: serializeErrors(staticContext.errors)
    };
    let initialScripts = [
      `_ROUTER_DATA = ${serializeJson(_ROUTER_DATA)};`,
      `_ROUTER_DATA.s = ${setupFnStr}`,
      `_ROUTER_DATA.r = ${resolveFnStr}`,
      `_ROUTER_DATA.p = ${preResolvedFnStr}`
    ].join("\n");
    const deferredDataScripts = [];
    initialScripts += Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
      const pendingKeys = new Set(deferredData.pendingKeys);
      const { deferredKeys } = deferredData;
      const deferredKeyPromiseStr = deferredKeys.map((key) => {
        if (pendingKeys.has(key)) {
          deferredDataScripts.push(/* @__PURE__ */ _jsx(DeferredDataScript, {
            nonce: props === null || props === void 0 ? void 0 : props.nonce,
            data: deferredData.data[key],
            dataKey: key,
            routeId
          }, `${routeId} | ${key}`));
          return `${JSON.stringify(key)}: _ROUTER_DATA.s(${JSON.stringify(routeId)},${JSON.stringify(key)}) `;
        } else {
          const trackedPromise = deferredData.data[key];
          if (typeof trackedPromise._error !== "undefined") {
            const error = {
              message: trackedPromise._error.message,
              stack: process.env.NODE_ENV !== "production" ? trackedPromise._error.stack : void 0
            };
            return `${JSON.stringify(key)}: _ROUTER_DATA.p(${void 0}, ${serializeJson(error)})`;
          } else {
            if (typeof trackedPromise._data === "undefined") {
              throw new Error(`The deferred data for ${key} was not resolved, did you forget to return data from a deferred promise`);
            }
            return `${JSON.stringify(key)}: _ROUTER_DATA.p(${serializeJson(trackedPromise._data)})`;
          }
        }
      }).join(",\n");
      return `Object.assign(_ROUTER_DATA.loaderData[${JSON.stringify(routeId)}], {${deferredKeyPromiseStr}});`;
    }).join("\n");
    return [
      initialScripts,
      deferredDataScripts
    ];
  }, []);
  if (!deferredScripts) {
    return null;
  }
  return /* @__PURE__ */ _jsxs(_Fragment, {
    children: [
      !hydratedRef.current && /* @__PURE__ */ _jsx("script", {
        async: true,
        nonce: props === null || props === void 0 ? void 0 : props.nonce,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: {
          __html: deferredScripts[0]
        }
      }),
      !hydratedRef.current && deferredScripts[1]
    ]
  });
};
const DeferredDataScript = ({ data, routeId, dataKey, nonce }) => {
  return /* @__PURE__ */ _jsx(Suspense, {
    children: typeof document === "undefined" && data && dataKey && routeId ? /* @__PURE__ */ _jsx(Await, {
      resolve: data,
      errorElement: /* @__PURE__ */ _jsx(ErrorDeferredDataScript, {
        routeId,
        dataKey,
        nonce
      }),
      children: (data2) => /* @__PURE__ */ _jsx("script", {
        async: true,
        nonce,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: {
          __html: `_ROUTER_DATA.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${serializeJson(data2)});`
        }
      })
    }) : null
  });
};
const ErrorDeferredDataScript = ({ routeId, dataKey, nonce }) => {
  const error = useAsyncError();
  return /* @__PURE__ */ _jsx("script", {
    nonce,
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `_ROUTER_DATA.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${void 0}, ${serializeJson({
        message: error.message,
        stack: error.stack
      })});`
    }
  });
};
var DeferredDataScripts_node_default = DeferredDataScripts;
export {
  DeferredDataScripts_node_default as default
};
