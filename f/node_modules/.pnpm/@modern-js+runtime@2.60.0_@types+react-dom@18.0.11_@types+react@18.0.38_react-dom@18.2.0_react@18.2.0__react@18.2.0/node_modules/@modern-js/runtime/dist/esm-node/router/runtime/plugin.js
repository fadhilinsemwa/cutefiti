import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { merge } from "@modern-js/runtime-utils/merge";
import { parsedJSONFromElement } from "@modern-js/runtime-utils/parsed";
import { RouterProvider, createBrowserRouter, createHashRouter, createRoutesFromElements, useHref, useLocation, useMatches } from "@modern-js/runtime-utils/router";
import { useContext, useMemo } from "react";
import { RuntimeReactContext } from "../../core";
import { getGlobalLayoutApp, getGlobalRoutes } from "../../core/context";
import { modifyRoutes as modifyRoutesHook } from "./hooks";
import { deserializeErrors, renderRoutes, urlJoin } from "./utils";
let finalRouteConfig = {
  routes: []
};
let beforeCreateRouter = true;
function modifyRoutes(modifyFunction) {
  if (beforeCreateRouter) {
    const { routes: originRoutes } = finalRouteConfig;
    const newRoutes = modifyFunction(originRoutes);
    finalRouteConfig.routes = newRoutes;
  } else {
    console.error("It is not allowed to modify routes config after create router.");
  }
}
const routerPlugin = (userConfig = {}) => {
  return {
    name: "@modern-js/plugin-router",
    registerHook: {
      modifyRoutes: modifyRoutesHook
    },
    setup: (api) => {
      let routes = [];
      window._SERVER_DATA = parsedJSONFromElement("__MODERN_SERVER_DATA__");
      return {
        beforeRender(context) {
          context.router = {
            useMatches,
            useLocation,
            useHref
          };
          Object.defineProperty(context, "routes", {
            get() {
              return routes;
            }
          });
        },
        wrapRoot: (App) => {
          const pluginConfig = api.useRuntimeConfigContext();
          const { serverBase = [], supportHtml5History = true, basename = "", routesConfig, createRoutes } = merge(pluginConfig.router || {}, userConfig);
          const select = (pathname) => serverBase.find((baseUrl) => pathname.search(baseUrl) === 0) || "/";
          finalRouteConfig = {
            routes: getGlobalRoutes(),
            globalApp: getGlobalLayoutApp(),
            ...routesConfig
          };
          if (!finalRouteConfig.routes && !createRoutes) {
            return App;
          }
          const getRouteApp = () => {
            const useCreateRouter = (props) => {
              var _window__SERVER_DATA;
              const runtimeContext = useContext(RuntimeReactContext);
              const baseUrl = (runtimeContext._internalRouterBaseName || ((_window__SERVER_DATA = window._SERVER_DATA) === null || _window__SERVER_DATA === void 0 ? void 0 : _window__SERVER_DATA.router.baseUrl) || select(location.pathname)).replace(/^\/*/, "/");
              const _basename = baseUrl === "/" ? urlJoin(baseUrl, basename) : baseUrl;
              let hydrationData = window._ROUTER_DATA;
              const { unstable_getBlockNavState: getBlockNavState } = runtimeContext;
              return useMemo(() => {
                if (hydrationData === null || hydrationData === void 0 ? void 0 : hydrationData.errors) {
                  hydrationData = {
                    ...hydrationData,
                    errors: deserializeErrors(hydrationData.errors)
                  };
                }
                routes = createRoutes ? createRoutes() : createRoutesFromElements(renderRoutes({
                  routesConfig: finalRouteConfig,
                  props
                }));
                const runner = api.useHookRunners();
                routes = runner.modifyRoutes(routes);
                const router = supportHtml5History ? createBrowserRouter(routes, {
                  basename: _basename,
                  hydrationData
                }) : createHashRouter(routes, {
                  basename: _basename,
                  hydrationData
                });
                const originSubscribe = router.subscribe;
                router.subscribe = (listener) => {
                  const wrapedListener = (...args) => {
                    const blockRoute = getBlockNavState ? getBlockNavState() : false;
                    if (blockRoute) {
                      return;
                    }
                    return listener(...args);
                  };
                  return originSubscribe(wrapedListener);
                };
                Object.defineProperty(runtimeContext, "remixRouter", {
                  get() {
                    return router;
                  },
                  configurable: true,
                  enumerable: true
                });
                return router;
              }, [
                finalRouteConfig,
                props,
                _basename,
                hydrationData,
                getBlockNavState
              ]);
            };
            const Null = () => null;
            return (props) => {
              beforeCreateRouter = false;
              const router = useCreateRouter(props);
              return (
                // To match the node tree about https://github.com/web-infra-dev/modern.js/blob/v2.59.0/packages/runtime/plugin-runtime/src/router/runtime/plugin.node.tsx#L150-L168
                // According to react [useId generation algorithm](https://github.com/facebook/react/pull/22644), `useId` will generate id with the react node react struct.
                // To void hydration failed, we must guarantee that the node tree when browser hydrate must have same struct with node tree when ssr render.
                /* @__PURE__ */ _jsxs(_Fragment, {
                  children: [
                    /* @__PURE__ */ _jsx(RouterProvider, {
                      router
                    }),
                    /* @__PURE__ */ _jsx(Null, {}),
                    /* @__PURE__ */ _jsx(Null, {})
                  ]
                })
              );
            };
          };
          return getRouteApp();
        },
        pickContext: (pickedContext) => {
          const { remixRouter } = pickedContext;
          if (!remixRouter) {
            return pickedContext;
          }
          const router = {
            ...pickedContext.router,
            navigate: remixRouter.navigate,
            get location() {
              return remixRouter.state.location;
            }
          };
          return {
            ...pickedContext,
            router
          };
        }
      };
    }
  };
};
export {
  beforeCreateRouter,
  finalRouteConfig,
  modifyRoutes,
  routerPlugin
};
