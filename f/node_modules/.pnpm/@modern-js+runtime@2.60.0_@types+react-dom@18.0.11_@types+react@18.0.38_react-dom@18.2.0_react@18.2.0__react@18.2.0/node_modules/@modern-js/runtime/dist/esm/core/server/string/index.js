import { _ as _async_to_generator } from "@swc/helpers/_/_async_to_generator";
import { _ as _to_consumable_array } from "@swc/helpers/_/_to_consumable_array";
import { _ as _ts_generator } from "@swc/helpers/_/_ts_generator";
import { run } from "@modern-js/runtime-utils/node";
import { time } from "@modern-js/runtime-utils/time";
import { parseHeaders } from "@modern-js/runtime-utils/universal/request";
import ReactDomServer from "react-dom/server";
import ReactHelmet from "react-helmet";
import { RenderLevel } from "../../constants";
import { wrapRuntimeContextProvider } from "../../react/wrapper";
import { CHUNK_CSS_PLACEHOLDER, CHUNK_JS_PLACEHOLDER, HTML_PLACEHOLDER, SSR_DATA_PLACEHOLDER } from "../constants";
import { createReplaceHelemt } from "../helmet";
import { buildHtml } from "../shared";
import { SSRErrors, SSRTimings, createOnError, createOnTiming } from "../tracer";
import { getSSRConfigByEntry, safeReplace } from "../utils";
import { LoadableCollector } from "./loadable";
import { prefetch } from "./prefetch";
import { SSRDataCollector } from "./ssrData";
import { StyledCollector } from "./styledComponent";
var renderString = function() {
  var _ref = _async_to_generator(function(request, serverRoot, options) {
    var headersData;
    return _ts_generator(this, function(_state) {
      headersData = parseHeaders(request);
      return [
        2,
        run(headersData, /* @__PURE__ */ _async_to_generator(function() {
          var _runtimeContext_ssrContext, resource, runtimeContext, config, onError, onTiming, tracer, routerContext, htmlTemplate, entryName, loadableStats, routeManifest, ssrConfig, chunkSet, prefetchData, e, collectors, rootElement, html;
          return _ts_generator(this, function(_state2) {
            switch (_state2.label) {
              case 0:
                resource = options.resource, runtimeContext = options.runtimeContext, config = options.config, onError = options.onError, onTiming = options.onTiming;
                tracer = {
                  onError: createOnError(onError),
                  onTiming: createOnTiming(onTiming)
                };
                routerContext = runtimeContext.routerContext;
                htmlTemplate = resource.htmlTemplate, entryName = resource.entryName, loadableStats = resource.loadableStats, routeManifest = resource.routeManifest;
                ssrConfig = getSSRConfigByEntry(entryName, config.ssr, config.ssrByEntries);
                chunkSet = {
                  renderLevel: RenderLevel.CLIENT_RENDER,
                  ssrScripts: "",
                  jsChunk: "",
                  cssChunk: ""
                };
                prefetchData = {};
                _state2.label = 1;
              case 1:
                _state2.trys.push([
                  1,
                  3,
                  ,
                  4
                ]);
                return [
                  4,
                  prefetch(serverRoot, request, options, ssrConfig, tracer)
                ];
              case 2:
                prefetchData = _state2.sent();
                chunkSet.renderLevel = RenderLevel.SERVER_PREFETCH;
                return [
                  3,
                  4
                ];
              case 3:
                e = _state2.sent();
                chunkSet.renderLevel = RenderLevel.CLIENT_RENDER;
                tracer.onError(SSRErrors.PRERENDER, e);
                return [
                  3,
                  4
                ];
              case 4:
                collectors = [
                  new StyledCollector(chunkSet),
                  new LoadableCollector({
                    stats: loadableStats,
                    nonce: config.nonce,
                    routeManifest,
                    template: htmlTemplate,
                    entryName,
                    chunkSet,
                    config
                  }),
                  new SSRDataCollector({
                    request,
                    prefetchData,
                    ssrConfig,
                    ssrContext: runtimeContext.ssrContext,
                    chunkSet,
                    routerContext,
                    nonce: config.nonce
                  })
                ];
                rootElement = wrapRuntimeContextProvider(serverRoot, Object.assign(runtimeContext, {
                  ssr: true
                }));
                return [
                  4,
                  generateHtml(rootElement, htmlTemplate, chunkSet, collectors, ((_runtimeContext_ssrContext = runtimeContext.ssrContext) === null || _runtimeContext_ssrContext === void 0 ? void 0 : _runtimeContext_ssrContext.htmlModifiers) || [], tracer)
                ];
              case 5:
                html = _state2.sent();
                return [
                  2,
                  html
                ];
            }
          });
        }))
      ];
    });
  });
  return function renderString2(request, serverRoot, options) {
    return _ref.apply(this, arguments);
  };
}();
function generateHtml(App, htmlTemplate, chunkSet, collectors, htmlModifiers, _) {
  return _generateHtml.apply(this, arguments);
}
function _generateHtml() {
  _generateHtml = _async_to_generator(function(App, htmlTemplate, chunkSet, collectors, htmlModifiers, param) {
    var onError, onTiming, html, helmetData, finalApp, end, cost, ssrScripts, cssChunk, jsChunk, finalHtml;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          onError = param.onError, onTiming = param.onTiming;
          html = "";
          finalApp = collectors.reduce(function(pre, creator) {
            var _creator_collect;
            return ((_creator_collect = creator.collect) === null || _creator_collect === void 0 ? void 0 : _creator_collect.call(creator, pre)) || pre;
          }, App);
          try {
            end = time();
            if (chunkSet.renderLevel >= RenderLevel.SERVER_PREFETCH) {
              html = ReactDomServer.renderToString(finalApp);
              chunkSet.renderLevel = RenderLevel.SERVER_RENDER;
            }
            helmetData = ReactHelmet.renderStatic();
            cost = end();
            onTiming(SSRTimings.RENDER_HTML, cost);
          } catch (e) {
            chunkSet.renderLevel = RenderLevel.CLIENT_RENDER;
            onError(SSRErrors.RENDER_HTML, e);
          }
          return [
            4,
            Promise.all(collectors.map(function(component) {
              return component.effect();
            }))
          ];
        case 1:
          _state.sent();
          ssrScripts = chunkSet.ssrScripts, cssChunk = chunkSet.cssChunk, jsChunk = chunkSet.jsChunk;
          return [
            4,
            buildHtml(htmlTemplate, [
              createReplaceHtml(html),
              createReplaceChunkJs(jsChunk),
              createReplaceChunkCss(cssChunk),
              createReplaceSSRDataScript(ssrScripts),
              createReplaceHelemt(helmetData)
            ].concat(_to_consumable_array(htmlModifiers)))
          ];
        case 2:
          finalHtml = _state.sent();
          return [
            2,
            finalHtml
          ];
      }
    });
  });
  return _generateHtml.apply(this, arguments);
}
function createReplaceHtml(html) {
  return function(template) {
    return safeReplace(template, HTML_PLACEHOLDER, html);
  };
}
function createReplaceSSRDataScript(data) {
  return function(template) {
    return safeReplace(template, SSR_DATA_PLACEHOLDER, data);
  };
}
function createReplaceChunkJs(js) {
  return function(template) {
    return safeReplace(template, CHUNK_JS_PLACEHOLDER, js);
  };
}
function createReplaceChunkCss(css) {
  return function(template) {
    return safeReplace(template, CHUNK_CSS_PLACEHOLDER, css);
  };
}
export {
  renderString
};
