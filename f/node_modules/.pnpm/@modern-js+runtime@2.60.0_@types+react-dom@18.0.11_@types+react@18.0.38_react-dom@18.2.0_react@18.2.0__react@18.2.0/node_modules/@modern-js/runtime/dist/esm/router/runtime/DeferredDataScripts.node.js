import { _ as _sliced_to_array } from "@swc/helpers/_/_sliced_to_array";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { serializeJson } from "@modern-js/runtime-utils/node";
import { Await, useAsyncError } from "@modern-js/runtime-utils/router";
import { Suspense, useEffect, useMemo, useRef } from "react";
import { serializeErrors } from "./utils";
var setupFnStr = "function s(r,e){_ROUTER_DATA.r=_ROUTER_DATA.r||{},_ROUTER_DATA.r[r]=_ROUTER_DATA.r[r]||{};return new Promise((function(A,R){_ROUTER_DATA.r[r][e]={resolve:A,reject:R}}))};";
var resolveFnStr = "function r(e,r,o,A){A?_ROUTER_DATA.r[e][r].reject(A):_ROUTER_DATA.r[e][r].resolve(o)};";
var preResolvedFnStr = "function p(e,r){return void 0!==r?Promise.reject(new Error(r.message)):Promise.resolve(e)};";
var DeferredDataScripts = function(props) {
  var staticContext = props === null || props === void 0 ? void 0 : props.context;
  var hydratedRef = useRef(false);
  useEffect(function() {
    hydratedRef.current = true;
  }, []);
  var deferredScripts = useMemo(function() {
    if (!staticContext) {
      return null;
    }
    var activeDeferreds = staticContext.activeDeferreds || [];
    var _ROUTER_DATA = {
      loaderData: staticContext.loaderData,
      errors: serializeErrors(staticContext.errors)
    };
    var initialScripts = [
      "_ROUTER_DATA = ".concat(serializeJson(_ROUTER_DATA), ";"),
      "_ROUTER_DATA.s = ".concat(setupFnStr),
      "_ROUTER_DATA.r = ".concat(resolveFnStr),
      "_ROUTER_DATA.p = ".concat(preResolvedFnStr)
    ].join("\n");
    var deferredDataScripts = [];
    initialScripts += Object.entries(activeDeferreds).map(function(param) {
      var _param = _sliced_to_array(param, 2), routeId = _param[0], deferredData = _param[1];
      var pendingKeys = new Set(deferredData.pendingKeys);
      var deferredKeys = deferredData.deferredKeys;
      var deferredKeyPromiseStr = deferredKeys.map(function(key) {
        if (pendingKeys.has(key)) {
          deferredDataScripts.push(/* @__PURE__ */ _jsx(DeferredDataScript, {
            nonce: props === null || props === void 0 ? void 0 : props.nonce,
            data: deferredData.data[key],
            dataKey: key,
            routeId
          }, "".concat(routeId, " | ").concat(key)));
          return "".concat(JSON.stringify(key), ": _ROUTER_DATA.s(").concat(JSON.stringify(routeId), ",").concat(JSON.stringify(key), ") ");
        } else {
          var trackedPromise = deferredData.data[key];
          if (typeof trackedPromise._error !== "undefined") {
            var error = {
              message: trackedPromise._error.message,
              stack: process.env.NODE_ENV !== "production" ? trackedPromise._error.stack : void 0
            };
            return "".concat(JSON.stringify(key), ": _ROUTER_DATA.p(").concat(void 0, ", ").concat(serializeJson(error), ")");
          } else {
            if (typeof trackedPromise._data === "undefined") {
              throw new Error("The deferred data for ".concat(key, " was not resolved, did you forget to return data from a deferred promise"));
            }
            return "".concat(JSON.stringify(key), ": _ROUTER_DATA.p(").concat(serializeJson(trackedPromise._data), ")");
          }
        }
      }).join(",\n");
      return "Object.assign(_ROUTER_DATA.loaderData[".concat(JSON.stringify(routeId), "], {").concat(deferredKeyPromiseStr, "});");
    }).join("\n");
    return [
      initialScripts,
      deferredDataScripts
    ];
  }, []);
  if (!deferredScripts) {
    return null;
  }
  return /* @__PURE__ */ _jsxs(_Fragment, {
    children: [
      !hydratedRef.current && /* @__PURE__ */ _jsx("script", {
        async: true,
        nonce: props === null || props === void 0 ? void 0 : props.nonce,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: {
          __html: deferredScripts[0]
        }
      }),
      !hydratedRef.current && deferredScripts[1]
    ]
  });
};
var DeferredDataScript = function(param) {
  var data = param.data, routeId = param.routeId, dataKey = param.dataKey, nonce = param.nonce;
  return /* @__PURE__ */ _jsx(Suspense, {
    children: typeof document === "undefined" && data && dataKey && routeId ? /* @__PURE__ */ _jsx(Await, {
      resolve: data,
      errorElement: /* @__PURE__ */ _jsx(ErrorDeferredDataScript, {
        routeId,
        dataKey,
        nonce
      }),
      children: function(data2) {
        return /* @__PURE__ */ _jsx("script", {
          async: true,
          nonce,
          suppressHydrationWarning: true,
          dangerouslySetInnerHTML: {
            __html: "_ROUTER_DATA.r(".concat(JSON.stringify(routeId), ", ").concat(JSON.stringify(dataKey), ", ").concat(serializeJson(data2), ");")
          }
        });
      }
    }) : null
  });
};
var ErrorDeferredDataScript = function(param) {
  var routeId = param.routeId, dataKey = param.dataKey, nonce = param.nonce;
  var error = useAsyncError();
  return /* @__PURE__ */ _jsx("script", {
    nonce,
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: "_ROUTER_DATA.r(".concat(JSON.stringify(routeId), ", ").concat(JSON.stringify(dataKey), ", ").concat(void 0, ", ").concat(serializeJson({
        message: error.message,
        stack: error.stack
      }), ");")
    }
  });
};
var DeferredDataScripts_node_default = DeferredDataScripts;
export {
  DeferredDataScripts_node_default as default
};
