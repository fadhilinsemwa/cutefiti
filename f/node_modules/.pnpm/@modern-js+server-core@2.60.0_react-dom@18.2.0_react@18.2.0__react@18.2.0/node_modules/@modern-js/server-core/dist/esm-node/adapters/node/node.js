import { ServerResponse } from "node:http";
import { installGlobals } from "./polyfills/install";
import { createReadableStreamFromReadable, writeReadableStreamToWritable } from "./polyfills/stream";
import { writeReadableStreamToWritable as writeReadableStreamToWritable2 } from "./polyfills";
installGlobals();
const createWebRequest = (req, res, body) => {
  var _req_url;
  const headerRecord = [];
  const len = req.rawHeaders.length;
  for (let i = 0; i < len; i += 2) {
    headerRecord.push([
      req.rawHeaders[i],
      req.rawHeaders[i + 1]
    ]);
  }
  const { method } = req;
  const controller = new AbortController();
  const init = {
    method,
    headers: headerRecord,
    signal: controller.signal
  };
  res.on("close", () => controller.abort("res closed"));
  if (body || !(method === "GET" || method === "HEAD") && ((_req_url = req.url) === null || _req_url === void 0 ? void 0 : _req_url.includes("__loader"))) {
    init.body = body !== null && body !== void 0 ? body : createReadableStreamFromReadable(req);
    init.duplex = "half";
  }
  const url = `http://${req.headers.host}${req.url}`;
  const request = new Request(url, init);
  return request;
};
const sendResponse = async (response, res) => {
  var _response_headers_get;
  res.statusMessage = response.statusText;
  res.statusCode = response.status;
  const cookies = [];
  for (const [key, value] of response.headers.entries()) {
    if (key === "set-cookie") {
      cookies.push(value);
    } else {
      res.setHeader(key, value);
    }
  }
  if (cookies.length > 0) {
    res.setHeader("set-cookie", cookies);
  }
  if (((_response_headers_get = response.headers.get("Content-Type")) === null || _response_headers_get === void 0 ? void 0 : _response_headers_get.match(/text\/event-stream/i)) && res instanceof ServerResponse) {
    res.flushHeaders();
  }
  if (response.body) {
    await writeReadableStreamToWritable(response.body, res);
  } else {
    res.end();
  }
};
const handleResponseError = (e, res) => {
  const err = e instanceof Error ? e : new Error("unknown error", {
    cause: e
  });
  if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
    console.info("The user aborted a request.");
  } else {
    console.error(e);
    if (!res.headersSent) {
      res.writeHead(500, {
        "Content-Type": "text/plain"
      });
    }
    res.end(`Error: ${err.message}`);
    res.destroy(err);
  }
};
const getRequestListener = (handler) => {
  return async (req, res) => {
    try {
      const request = createWebRequest(req, res);
      const response = await handler(request, {
        node: {
          req,
          res
        }
      });
      if (!res.headersSent && !response.res && !res._modernBodyPiped) {
        await sendResponse(response, res);
      }
    } catch (error) {
      return handleResponseError(error, res);
    }
  };
};
const createNodeServer = async (requestHandler, httpsOptions) => {
  const requestListener = getRequestListener(requestHandler);
  let nodeServer;
  if (httpsOptions) {
    const { createServer } = await import("node:https");
    nodeServer = createServer(httpsOptions, requestListener);
  } else {
    const { createServer } = await import("node:http");
    nodeServer = createServer(requestListener);
  }
  nodeServer.getRequestListener = () => requestListener;
  nodeServer.getRequestHandler = () => requestHandler;
  return nodeServer;
};
export {
  createNodeServer,
  createWebRequest,
  sendResponse,
  writeReadableStreamToWritable2 as writeReadableStreamToWritable
};
