import { isAbsolute } from "node:path";
import { pathToFileURL } from "node:url";
import { findExists } from "./fs";
async function compatibleRequire(path, interop = true) {
  if (path.endsWith(".json")) {
    return require(path);
  }
  let requiredModule;
  try {
    requiredModule = require(path);
  } catch (err) {
    if (err.code === "ERR_REQUIRE_ESM" || err instanceof SyntaxError) {
      const modulePath = isAbsolute(path) ? pathToFileURL(path).href : path;
      requiredModule = await import(modulePath);
      return interop ? requiredModule.default : requiredModule;
    } else {
      throw err;
    }
  }
  return interop && (requiredModule === null || requiredModule === void 0 ? void 0 : requiredModule.__esModule) ? requiredModule.default : requiredModule;
}
const dynamicImport = new Function("modulePath", "return import(modulePath)");
const requireExistModule = async (filename, opt) => {
  const final = {
    extensions: [
      ".ts",
      ".js"
    ],
    interop: true,
    ...opt
  };
  const exist = findExists(final.extensions.map((ext) => `${filename}${ext}`));
  if (!exist) {
    return null;
  }
  return compatibleRequire(exist, final.interop);
};
const cleanRequireCache = (filelist) => {
  filelist.forEach((filepath) => {
    delete require.cache[filepath];
  });
};
function deleteRequireCache(path) {
  if (require.cache[path]) {
    delete require.cache[path];
  }
  if (module.children) {
    module.children = module.children.filter((item) => item.filename !== path);
  }
}
const tryResolve = (name, resolvePath) => {
  let filePath = "";
  try {
    filePath = require.resolve(name, {
      paths: [
        resolvePath
      ]
    });
    delete require.cache[filePath];
  } catch (err) {
    if (err.code === "MODULE_NOT_FOUND") {
      throw new Error(`Can not find module ${name}.`);
    }
    throw err;
  }
  return filePath;
};
export {
  cleanRequireCache,
  compatibleRequire,
  deleteRequireCache,
  dynamicImport,
  requireExistModule,
  tryResolve
};
