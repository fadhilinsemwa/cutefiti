"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/AsyncChunkRetryPlugin.ts
var AsyncChunkRetryPlugin_exports = {};
__export(AsyncChunkRetryPlugin_exports, {
  AsyncChunkRetryPlugin: () => AsyncChunkRetryPlugin
});
function appendWebpackScript(module2, appendSource) {
  try {
    const originSource = module2.getGeneratedCode();
    module2.getGeneratedCode = () => `${originSource}
${appendSource}`;
  } catch (err) {
    console.error("Failed to modify Webpack RuntimeModule");
    throw err;
  }
}
function appendRspackScript(module2, appendSource) {
  try {
    const source = module2.source.source.toString();
    module2.source.source = Buffer.from(`${source}
${appendSource}`, "utf-8");
  } catch (err) {
    console.error("Failed to modify Rspack RuntimeModule");
    throw err;
  }
}
function pick(obj, keys) {
  return keys.reduce(
    (ret, key) => {
      if (obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    },
    {}
  );
}
var import_node_fs, import_node_path, import_core, import_serialize_javascript, AsyncChunkRetryPlugin;
var init_AsyncChunkRetryPlugin = __esm({
  "src/AsyncChunkRetryPlugin.ts"() {
    "use strict";
    import_node_fs = __toESM(require("fs"));
    import_node_path = __toESM(require("path"));
    import_core = require("@rsbuild/core");
    import_serialize_javascript = __toESM(require("serialize-javascript"));
    AsyncChunkRetryPlugin = class {
      constructor(options) {
        __publicField(this, "name", "ASYNC_CHUNK_RETRY_PLUGIN");
        __publicField(this, "options");
        __publicField(this, "runtimeOptions");
        this.options = options;
        this.runtimeOptions = pick(options, [
          "domain",
          "max",
          "onRetry",
          "onSuccess",
          "onFail",
          "addQuery",
          "test"
        ]);
      }
      getRawRuntimeRetryCode() {
        const { RuntimeGlobals } = import_core.rspack;
        const filename = "asyncChunkRetry";
        const runtimeFilePath = import_node_path.default.join(
          __dirname,
          "runtime",
          this.options.minify ? `${filename}.min.js` : `${filename}.js`
        );
        const rawText = import_node_fs.default.readFileSync(runtimeFilePath, "utf-8");
        return rawText.replaceAll("__RUNTIME_GLOBALS_REQUIRE__", RuntimeGlobals.require).replaceAll(
          "__RUNTIME_GLOBALS_ENSURE_CHUNK__",
          RuntimeGlobals.ensureChunk
        ).replaceAll(
          "__RUNTIME_GLOBALS_GET_CHUNK_SCRIPT_FILENAME__",
          RuntimeGlobals.getChunkScriptFilename
        ).replaceAll(
          "__RUNTIME_GLOBALS_GET_CSS_FILENAME__",
          RuntimeGlobals.getChunkCssFilename
        ).replaceAll(
          "__RUNTIME_GLOBALS_GET_MINI_CSS_EXTRACT_FILENAME__",
          "__webpack_require__.miniCssF"
        ).replaceAll("__RUNTIME_GLOBALS_PUBLIC_PATH__", RuntimeGlobals.publicPath).replaceAll("__RUNTIME_GLOBALS_LOAD_SCRIPT__", RuntimeGlobals.loadScript).replaceAll("__RETRY_OPTIONS__", (0, import_serialize_javascript.default)(this.runtimeOptions));
      }
      apply(compiler) {
        compiler.hooks.thisCompilation.tap(this.name, (compilation) => {
          compilation.hooks.runtimeModule.tap(this.name, (module2) => {
            const { isRspack } = this.options;
            const constructorName = isRspack ? module2.constructorName : module2.constructor?.name;
            const isPublicPathModule = module2.name === "publicPath" || constructorName === "PublicPathRuntimeModule" || constructorName === "AutoPublicPathRuntimeModule";
            if (!isPublicPathModule) {
              return;
            }
            const runtimeCode = this.getRawRuntimeRetryCode();
            if (isRspack) {
              appendRspackScript(module2, runtimeCode);
            } else {
              appendWebpackScript(module2, runtimeCode);
            }
          });
        });
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PLUGIN_ASSETS_RETRY_NAME: () => PLUGIN_ASSETS_RETRY_NAME,
  pluginAssetsRetry: () => pluginAssetsRetry
});
module.exports = __toCommonJS(src_exports);
var import_node_fs2 = __toESM(require("fs"));
var import_node_path2 = __toESM(require("path"));
var import_core2 = require("@rsbuild/core");
var PLUGIN_ASSETS_RETRY_NAME = "rsbuild:assets-retry";
async function getRetryCode(options) {
  const { default: serialize2 } = await import("serialize-javascript");
  const filename = "initialChunkRetry";
  const { minify, inlineScript: _, ...restOptions } = options;
  const runtimeFilePath = import_node_path2.default.join(
    __dirname,
    "runtime",
    minify ? `${filename}.min.js` : `${filename}.js`
  );
  const runtimeCode = await import_node_fs2.default.promises.readFile(runtimeFilePath, "utf-8");
  return `(function(){${runtimeCode};init(${serialize2(restOptions)});})()`;
}
var pluginAssetsRetry = (userOptions = {}) => ({
  name: PLUGIN_ASSETS_RETRY_NAME,
  setup(api) {
    const { inlineScript = true } = userOptions;
    const getScriptPath = (environment) => {
      const distDir = environment.config.output.distPath.js;
      return import_node_path2.default.posix.join(distDir, `assets-retry.${"1.0.1"}.js`);
    };
    const formatOptions = (config) => {
      const options = { ...userOptions };
      if (options.crossOrigin === void 0) {
        options.crossOrigin = config.html.crossorigin;
      }
      if (options.minify === void 0) {
        const minify = typeof config.output.minify === "boolean" ? config.output.minify : config.output.minify?.js;
        options.minify = minify && config.mode === "production";
      }
      return options;
    };
    if (inlineScript) {
      api.modifyHTMLTags(async ({ headTags, bodyTags }, { environment }) => {
        const code = await getRetryCode(formatOptions(environment.config));
        headTags.unshift({
          tag: "script",
          attrs: {},
          children: code
        });
        return { headTags, bodyTags };
      });
    } else {
      api.modifyHTMLTags(
        async ({ headTags, bodyTags }, { assetPrefix, environment }) => {
          const scriptPath = getScriptPath(environment);
          const url = (0, import_core2.ensureAssetPrefix)(scriptPath, assetPrefix);
          headTags.unshift({
            tag: "script",
            attrs: {
              src: url
            }
          });
          return { headTags, bodyTags };
        }
      );
      api.processAssets(
        { stage: "additional" },
        async ({ sources, compilation, environment }) => {
          const scriptPath = getScriptPath(environment);
          const code = await getRetryCode(formatOptions(environment.config));
          compilation.emitAsset(scriptPath, new sources.RawSource(code));
        }
      );
    }
    api.modifyBundlerChain(async (chain, { environment }) => {
      const { config, htmlPaths } = environment;
      if (!userOptions || Object.keys(htmlPaths).length === 0) {
        return;
      }
      const { AsyncChunkRetryPlugin: AsyncChunkRetryPlugin2 } = await Promise.resolve().then(() => (init_AsyncChunkRetryPlugin(), AsyncChunkRetryPlugin_exports));
      const options = formatOptions(config);
      const isRspack = api.context.bundlerType === "rspack";
      chain.plugin("async-chunk-retry").use(AsyncChunkRetryPlugin2, [{ ...options, isRspack }]);
    });
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_ASSETS_RETRY_NAME,
  pluginAssetsRetry
});
