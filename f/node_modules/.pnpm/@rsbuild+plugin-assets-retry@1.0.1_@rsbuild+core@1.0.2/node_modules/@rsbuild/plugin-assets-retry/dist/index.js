import { createRequire } from 'module';
var require = createRequire(import.meta['url']);

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/.pnpm/@modern-js+module-tools@2.59.0_typescript@5.5.2/node_modules/@modern-js/module-tools/shims/esm.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename, getDirname, __dirname;
var init_esm = __esm({
  "../../node_modules/.pnpm/@modern-js+module-tools@2.59.0_typescript@5.5.2/node_modules/@modern-js/module-tools/shims/esm.js"() {
    "use strict";
    getFilename = () => fileURLToPath(import.meta.url);
    getDirname = () => path.dirname(getFilename());
    __dirname = /* @__PURE__ */ getDirname();
  }
});

// src/AsyncChunkRetryPlugin.ts
var AsyncChunkRetryPlugin_exports = {};
__export(AsyncChunkRetryPlugin_exports, {
  AsyncChunkRetryPlugin: () => AsyncChunkRetryPlugin
});
import fs from "fs";
import path2 from "path";
import { rspack } from "@rsbuild/core";
import serialize from "serialize-javascript";
function appendWebpackScript(module, appendSource) {
  try {
    const originSource = module.getGeneratedCode();
    module.getGeneratedCode = () => `${originSource}
${appendSource}`;
  } catch (err) {
    console.error("Failed to modify Webpack RuntimeModule");
    throw err;
  }
}
function appendRspackScript(module, appendSource) {
  try {
    const source = module.source.source.toString();
    module.source.source = Buffer.from(`${source}
${appendSource}`, "utf-8");
  } catch (err) {
    console.error("Failed to modify Rspack RuntimeModule");
    throw err;
  }
}
function pick(obj, keys) {
  return keys.reduce(
    (ret, key) => {
      if (obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    },
    {}
  );
}
var AsyncChunkRetryPlugin;
var init_AsyncChunkRetryPlugin = __esm({
  "src/AsyncChunkRetryPlugin.ts"() {
    "use strict";
    init_esm();
    AsyncChunkRetryPlugin = class {
      constructor(options) {
        __publicField(this, "name", "ASYNC_CHUNK_RETRY_PLUGIN");
        __publicField(this, "options");
        __publicField(this, "runtimeOptions");
        this.options = options;
        this.runtimeOptions = pick(options, [
          "domain",
          "max",
          "onRetry",
          "onSuccess",
          "onFail",
          "addQuery",
          "test"
        ]);
      }
      getRawRuntimeRetryCode() {
        const { RuntimeGlobals } = rspack;
        const filename = "asyncChunkRetry";
        const runtimeFilePath = path2.join(
          __dirname,
          "runtime",
          this.options.minify ? `${filename}.min.js` : `${filename}.js`
        );
        const rawText = fs.readFileSync(runtimeFilePath, "utf-8");
        return rawText.replaceAll("__RUNTIME_GLOBALS_REQUIRE__", RuntimeGlobals.require).replaceAll(
          "__RUNTIME_GLOBALS_ENSURE_CHUNK__",
          RuntimeGlobals.ensureChunk
        ).replaceAll(
          "__RUNTIME_GLOBALS_GET_CHUNK_SCRIPT_FILENAME__",
          RuntimeGlobals.getChunkScriptFilename
        ).replaceAll(
          "__RUNTIME_GLOBALS_GET_CSS_FILENAME__",
          RuntimeGlobals.getChunkCssFilename
        ).replaceAll(
          "__RUNTIME_GLOBALS_GET_MINI_CSS_EXTRACT_FILENAME__",
          "__webpack_require__.miniCssF"
        ).replaceAll("__RUNTIME_GLOBALS_PUBLIC_PATH__", RuntimeGlobals.publicPath).replaceAll("__RUNTIME_GLOBALS_LOAD_SCRIPT__", RuntimeGlobals.loadScript).replaceAll("__RETRY_OPTIONS__", serialize(this.runtimeOptions));
      }
      apply(compiler) {
        compiler.hooks.thisCompilation.tap(this.name, (compilation) => {
          compilation.hooks.runtimeModule.tap(this.name, (module) => {
            const { isRspack } = this.options;
            const constructorName = isRspack ? module.constructorName : module.constructor?.name;
            const isPublicPathModule = module.name === "publicPath" || constructorName === "PublicPathRuntimeModule" || constructorName === "AutoPublicPathRuntimeModule";
            if (!isPublicPathModule) {
              return;
            }
            const runtimeCode = this.getRawRuntimeRetryCode();
            if (isRspack) {
              appendRspackScript(module, runtimeCode);
            } else {
              appendWebpackScript(module, runtimeCode);
            }
          });
        });
      }
    };
  }
});

// src/index.ts
init_esm();
import fs2 from "fs";
import path3 from "path";
import { ensureAssetPrefix } from "@rsbuild/core";
var PLUGIN_ASSETS_RETRY_NAME = "rsbuild:assets-retry";
async function getRetryCode(options) {
  const { default: serialize2 } = await import("serialize-javascript");
  const filename = "initialChunkRetry";
  const { minify, inlineScript: _, ...restOptions } = options;
  const runtimeFilePath = path3.join(
    __dirname,
    "runtime",
    minify ? `${filename}.min.js` : `${filename}.js`
  );
  const runtimeCode = await fs2.promises.readFile(runtimeFilePath, "utf-8");
  return `(function(){${runtimeCode};init(${serialize2(restOptions)});})()`;
}
var pluginAssetsRetry = (userOptions = {}) => ({
  name: PLUGIN_ASSETS_RETRY_NAME,
  setup(api) {
    const { inlineScript = true } = userOptions;
    const getScriptPath = (environment) => {
      const distDir = environment.config.output.distPath.js;
      return path3.posix.join(distDir, `assets-retry.${"1.0.1"}.js`);
    };
    const formatOptions = (config) => {
      const options = { ...userOptions };
      if (options.crossOrigin === void 0) {
        options.crossOrigin = config.html.crossorigin;
      }
      if (options.minify === void 0) {
        const minify = typeof config.output.minify === "boolean" ? config.output.minify : config.output.minify?.js;
        options.minify = minify && config.mode === "production";
      }
      return options;
    };
    if (inlineScript) {
      api.modifyHTMLTags(async ({ headTags, bodyTags }, { environment }) => {
        const code = await getRetryCode(formatOptions(environment.config));
        headTags.unshift({
          tag: "script",
          attrs: {},
          children: code
        });
        return { headTags, bodyTags };
      });
    } else {
      api.modifyHTMLTags(
        async ({ headTags, bodyTags }, { assetPrefix, environment }) => {
          const scriptPath = getScriptPath(environment);
          const url = ensureAssetPrefix(scriptPath, assetPrefix);
          headTags.unshift({
            tag: "script",
            attrs: {
              src: url
            }
          });
          return { headTags, bodyTags };
        }
      );
      api.processAssets(
        { stage: "additional" },
        async ({ sources, compilation, environment }) => {
          const scriptPath = getScriptPath(environment);
          const code = await getRetryCode(formatOptions(environment.config));
          compilation.emitAsset(scriptPath, new sources.RawSource(code));
        }
      );
    }
    api.modifyBundlerChain(async (chain, { environment }) => {
      const { config, htmlPaths } = environment;
      if (!userOptions || Object.keys(htmlPaths).length === 0) {
        return;
      }
      const { AsyncChunkRetryPlugin: AsyncChunkRetryPlugin2 } = await Promise.resolve().then(() => (init_AsyncChunkRetryPlugin(), AsyncChunkRetryPlugin_exports));
      const options = formatOptions(config);
      const isRspack = api.context.bundlerType === "rspack";
      chain.plugin("async-chunk-retry").use(AsyncChunkRetryPlugin2, [{ ...options, isRspack }]);
    });
  }
});
export {
  PLUGIN_ASSETS_RETRY_NAME,
  pluginAssetsRetry
};
