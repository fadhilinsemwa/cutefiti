"use strict";

var _ref, _RUNTIME_GLOBALS_GET;
// rsbuild/runtime/async-chunk-retry

// e.g: src_AsyncCompTest_tsx
// e.g: static/js/async/src_AsyncCompTest_tsx.js
// publicPath + ChunkFilename e.g: http://localhost:3000/static/js/async/src_AsyncCompTest_tsx.js

// init retryCollector and nextRetry function
var config = __RETRY_OPTIONS__;
var maxRetries = config.max || 3;
var retryCollector = {};
function findCurrentDomain(url) {
  var _config$domain;
  var domainList = (_config$domain = config.domain) !== null && _config$domain !== void 0 ? _config$domain : [];
  var domain = '';
  for (var i = 0; i < domainList.length; i++) {
    if (url.indexOf(domainList[i]) !== -1) {
      domain = domainList[i];
      break;
    }
  }
  return domain || window.origin;
}
function findNextDomain(url) {
  var _config$domain2;
  var domainList = (_config$domain2 = config.domain) !== null && _config$domain2 !== void 0 ? _config$domain2 : [];
  var currentDomain = findCurrentDomain(url);
  var index = domainList.indexOf(currentDomain);
  return domainList[(index + 1) % domainList.length] || url;
}
var postfixRE = /[?#].*$/;
function cleanUrl(url) {
  return url.replace(postfixRE, '');
}
function getQueryFromUrl(url) {
  var parts = url.split('?')[1];
  return parts ? "?".concat(parts.split('#')[0]) : '';
}
function getUrlRetryQuery(existRetryTimes, originalQuery) {
  if (config.addQuery === true) {
    return originalQuery !== '' ? "".concat(originalQuery, "&retry=").concat(existRetryTimes) : "?retry=".concat(existRetryTimes);
  }
  if (typeof config.addQuery === 'function') {
    return config.addQuery({
      times: existRetryTimes,
      originalQuery: originalQuery
    });
  }
  return '';
}
function removeDomainFromUrl(url) {
  var protocolStartIndex = url.indexOf('//');

  // case /app/main/static/js/index.js
  if (protocolStartIndex === -1 && url.startsWith('/')) {
    return url;
  }

  // case "//cdn.com/app/main/static/js/index.js"
  // case "http://cdn.com/app/main/static/js/index.js"
  var protocolEndIndex = protocolStartIndex + 2;
  var pathStartIndex = url.indexOf('/', protocolEndIndex);
  return url.slice(pathStartIndex);
}

// "http://cdn.com/app/main/static/js/index.js?query=1#hash" -> "/app/main/static/js/index.js"
function getAbsolutePathFromUrl(url) {
  return cleanUrl(removeDomainFromUrl(url));
}
function getNextRetryUrl(existRetryTimes, nextDomain, originalSrcUrl) {
  var absolutePath = getAbsolutePathFromUrl(originalSrcUrl);
  return nextDomain + absolutePath + getUrlRetryQuery(existRetryTimes, getQueryFromUrl(originalSrcUrl));
}
function getCurrentRetry(chunkId) {
  return retryCollector[chunkId];
}
function initRetry(chunkId) {
  var _config$domain$, _config$domain3;
  var originalScriptFilename = originalGetChunkScriptFilename(chunkId);
  var originalSrcUrl = __RUNTIME_GLOBALS_PUBLIC_PATH__ + originalScriptFilename;
  var existRetryTimes = 1;
  var nextDomain = (_config$domain$ = (_config$domain3 = config.domain) === null || _config$domain3 === void 0 ? void 0 : _config$domain3[0]) !== null && _config$domain$ !== void 0 ? _config$domain$ : window.origin;
  return {
    existRetryTimes: existRetryTimes,
    nextDomain: nextDomain,
    nextRetryUrl: getNextRetryUrl(existRetryTimes, nextDomain, originalSrcUrl),
    originalScriptFilename: originalScriptFilename,
    originalSrcUrl: originalSrcUrl
  };
}
function nextRetry(chunkId) {
  var currRetry = getCurrentRetry(chunkId);
  var nextRetry;
  if (!currRetry) {
    nextRetry = initRetry(chunkId);
  } else {
    var originalScriptFilename = currRetry.originalScriptFilename,
      originalSrcUrl = currRetry.originalSrcUrl;
    var existRetryTimes = currRetry.existRetryTimes + 1;
    var nextDomain = findNextDomain(currRetry.nextDomain);
    nextRetry = {
      existRetryTimes: existRetryTimes,
      nextDomain: nextDomain,
      nextRetryUrl: getNextRetryUrl(existRetryTimes, nextDomain, originalSrcUrl),
      originalScriptFilename: originalScriptFilename,
      originalSrcUrl: originalSrcUrl
    };
  }
  retryCollector[chunkId] = nextRetry;
  return nextRetry;
}

// rewrite webpack runtime with nextRetry()
var originalEnsureChunk = __RUNTIME_GLOBALS_ENSURE_CHUNK__;
var originalGetChunkScriptFilename = __RUNTIME_GLOBALS_GET_CHUNK_SCRIPT_FILENAME__;
var originalGetCssFilename = (_ref = (_RUNTIME_GLOBALS_GET = __RUNTIME_GLOBALS_GET_MINI_CSS_EXTRACT_FILENAME__) !== null && _RUNTIME_GLOBALS_GET !== void 0 ? _RUNTIME_GLOBALS_GET : __RUNTIME_GLOBALS_GET_CSS_FILENAME__) !== null && _ref !== void 0 ? _ref : function () {
  return null;
};
var originalLoadScript = __RUNTIME_GLOBALS_LOAD_SCRIPT__;

// if users want to support es5, add Promise polyfill first https://github.com/webpack/webpack/issues/12877
function ensureChunk(chunkId) {
  var result = originalEnsureChunk(chunkId);
  var originalScriptFilename = originalGetChunkScriptFilename(chunkId);
  var originalCssFilename = originalGetCssFilename(chunkId);

  // mark the async chunk name in the global variables and share it with initial chunk retry to avoid duplicate retrying
  if (typeof window !== 'undefined') {
    if (originalScriptFilename) {
      window.__RB_ASYNC_CHUNKS__[originalScriptFilename] = true;
    }
    if (originalCssFilename) {
      window.__RB_ASYNC_CHUNKS__[originalCssFilename] = true;
    }
  }
  return result.catch(function (error) {
    var _error$message;
    var _nextRetry = nextRetry(chunkId),
      existRetryTimes = _nextRetry.existRetryTimes,
      originalSrcUrl = _nextRetry.originalSrcUrl,
      nextRetryUrl = _nextRetry.nextRetryUrl,
      nextDomain = _nextRetry.nextDomain;

    // At present, we don't consider the switching domain and addQuery of async css chunk
    // 1. Async js chunk will be requested first. It is rare for async css chunk to fail alone.
    // 2. the code of loading css in webpack runtime is complex and it may be modified by cssExtractPlugin, increase the complexity of this plugin.
    var isCssAsyncChunkLoadFailed = Boolean(error === null || error === void 0 || (_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.includes('CSS chunk'));
    var createContext = function createContext(times) {
      return {
        times: times,
        domain: nextDomain,
        url: nextRetryUrl,
        tagName: isCssAsyncChunkLoadFailed ? 'link' : 'script',
        isAsyncChunk: true
      };
    };
    var context = createContext(existRetryTimes - 1);
    if (existRetryTimes > maxRetries) {
      error.message = "Loading chunk ".concat(chunkId, " from ").concat(originalSrcUrl, " failed after ").concat(maxRetries, " retries: \"").concat(error.message, "\"");
      if (typeof config.onFail === 'function') {
        config.onFail(context);
      }
      throw error;
    }

    // Filter by config.test and config.domain
    var tester = config.test;
    if (tester) {
      if (typeof tester === 'string') {
        var regexp = new RegExp(tester);
        tester = function tester(str) {
          return regexp.test(str);
        };
      }
      if (typeof tester !== 'function' || !tester(nextRetryUrl)) {
        throw error;
      }
    }
    if (config.domain && config.domain.length > 0 && config.domain.indexOf(nextDomain) === -1) {
      throw error;
    }

    // Start retry
    if (typeof config.onRetry === 'function') {
      config.onRetry(context);
    }
    return ensureChunk(chunkId).then(function (result) {
      if (typeof config.onSuccess === 'function') {
        var _getCurrentRetry;
        var _context = createContext(existRetryTimes);
        var _ref2 = (_getCurrentRetry = getCurrentRetry(chunkId)) !== null && _getCurrentRetry !== void 0 ? _getCurrentRetry : {},
          currRetryTimes = _ref2.existRetryTimes;
        if (currRetryTimes === existRetryTimes) {
          config.onSuccess(_context);
        }
      }
      return result;
    });
  });
}
function loadScript(originalUrl, done, key, chunkId) {
  var retry = getCurrentRetry(chunkId);
  return originalLoadScript(retry ? retry.nextRetryUrl : originalUrl, done, key, chunkId);
}
function registerAsyncChunkRetry() {
  // init global variables shared between initial-chunk-retry and async-chunk-retry
  if (typeof window !== 'undefined' && !window.__RB_ASYNC_CHUNKS__) {
    window.__RB_ASYNC_CHUNKS__ = {};
  }
  if (typeof __RUNTIME_GLOBALS_REQUIRE__ !== 'undefined') {
    try {
      __RUNTIME_GLOBALS_ENSURE_CHUNK__ = ensureChunk;
      __RUNTIME_GLOBALS_LOAD_SCRIPT__ = loadScript;
    } catch (e) {
      console.error('[@rsbuild/plugin-assets-retry] Register async chunk retry runtime failed', e);
    }
  }
}
registerAsyncChunkRetry();