(() => {
  var __webpack_modules__ = {
    722: (module) => {
      const STRIP_FILENAME_RE = /^[^:]+: /;
      const format = (err) => {
        if (err instanceof SyntaxError) {
          err.name = "SyntaxError";
          err.message = err.message.replace(STRIP_FILENAME_RE, "");
          err.hideStack = true;
        } else if (err instanceof TypeError) {
          err.name = null;
          err.message = err.message.replace(STRIP_FILENAME_RE, "");
          err.hideStack = true;
        }
        return err;
      };
      class LoaderError extends Error {
        constructor(err) {
          super();
          const { name, message, codeFrame, hideStack } = format(err);
          this.name = "BabelLoaderError";
          this.message = `${name ? `${name}: ` : ""}${message}\n\n${codeFrame}\n`;
          this.hideStack = hideStack;
          Error.captureStackTrace(this, this.constructor);
        }
      }
      module.exports = LoaderError;
    },
    765: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const os = __nccwpck_require__(37);
      const path = __nccwpck_require__(17);
      const zlib = __nccwpck_require__(796);
      const crypto = __nccwpck_require__(113);
      const { promisify } = __nccwpck_require__(837);
      const { readFile, writeFile, mkdir } = __nccwpck_require__(292);
      const findCacheDirP = __nccwpck_require__
        .e(672)
        .then(__nccwpck_require__.bind(__nccwpck_require__, 672));
      const transform = __nccwpck_require__(982);
      let defaultCacheDirectory = null;
      let hashType = "sha256";
      try {
        crypto.createHash(hashType);
      } catch (err) {
        hashType = "md5";
      }
      const gunzip = promisify(zlib.gunzip);
      const gzip = promisify(zlib.gzip);
      const read = async function (filename, compress) {
        const data = await readFile(filename + (compress ? ".gz" : ""));
        const content = compress ? await gunzip(data) : data;
        return JSON.parse(content.toString());
      };
      const write = async function (filename, compress, result) {
        const content = JSON.stringify(result);
        const data = compress ? await gzip(content) : content;
        return await writeFile(filename + (compress ? ".gz" : ""), data);
      };
      const filename = function (source, identifier, options) {
        const hash = crypto.createHash(hashType);
        const contents = JSON.stringify({ source, options, identifier });
        hash.update(contents);
        return hash.digest("hex") + ".json";
      };
      const handleCache = async function (directory, params) {
        const {
          source,
          options = {},
          cacheIdentifier,
          cacheDirectory,
          cacheCompression,
        } = params;
        const file = path.join(
          directory,
          filename(source, cacheIdentifier, options),
        );
        try {
          return await read(file, cacheCompression);
        } catch (err) {}
        const fallback =
          typeof cacheDirectory !== "string" && directory !== os.tmpdir();
        try {
          await mkdir(directory, { recursive: true });
        } catch (err) {
          if (fallback) {
            return handleCache(os.tmpdir(), params);
          }
          throw err;
        }
        const result = await transform(source, options);
        if (!result.externalDependencies.length) {
          try {
            await write(file, cacheCompression, result);
          } catch (err) {
            if (fallback) {
              return handleCache(os.tmpdir(), params);
            }
            throw err;
          }
        }
        return result;
      };
      module.exports = async function (params) {
        let directory;
        if (typeof params.cacheDirectory === "string") {
          directory = params.cacheDirectory;
        } else {
          if (defaultCacheDirectory === null) {
            const { default: findCacheDir } = await findCacheDirP;
            defaultCacheDirectory =
              findCacheDir({ name: "babel-loader" }) || os.tmpdir();
          }
          directory = defaultCacheDirectory;
        }
        return await handleCache(directory, params);
      };
    },
    767: (module, __unused_webpack_exports, __nccwpck_require__) => {
      let babel;
      try {
        babel = __nccwpck_require__(718);
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          err.message +=
            "\n babel-loader@9 requires Babel 7.12+ (the package '@babel/core'). " +
            "If you'd like to use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.";
        }
        throw err;
      }
      if (/^6\./.test(babel.version)) {
        throw new Error(
          "\n babel-loader@9 will not work with the '@babel/core@6' bridge package. " +
            "If you want to use Babel 6.x, install 'babel-loader@7'.",
        );
      }
      const { version } = __nccwpck_require__(684);
      const cache = __nccwpck_require__(765);
      const transform = __nccwpck_require__(982);
      const injectCaller = __nccwpck_require__(632);
      const schema = __nccwpck_require__(547);
      const { isAbsolute } = __nccwpck_require__(17);
      const validateOptions = __nccwpck_require__(14).validate;
      function subscribe(subscriber, metadata, context) {
        if (context[subscriber]) {
          context[subscriber](metadata);
        }
      }
      module.exports = makeLoader();
      module.exports.custom = makeLoader;
      function makeLoader(callback) {
        const overrides = callback ? callback(babel) : undefined;
        return function (source, inputSourceMap) {
          const callback = this.async();
          loader.call(this, source, inputSourceMap, overrides).then(
            (args) => callback(null, ...args),
            (err) => callback(err),
          );
        };
      }
      async function loader(source, inputSourceMap, overrides) {
        const filename = this.resourcePath;
        let loaderOptions = this.getOptions();
        validateOptions(schema, loaderOptions, { name: "Babel loader" });
        if (loaderOptions.customize != null) {
          if (typeof loaderOptions.customize !== "string") {
            throw new Error(
              "Customized loaders must be implemented as standalone modules.",
            );
          }
          if (!isAbsolute(loaderOptions.customize)) {
            throw new Error(
              "Customized loaders must be passed as absolute paths, since " +
                "babel-loader has no way to know what they would be relative to.",
            );
          }
          if (overrides) {
            throw new Error(
              "babel-loader's 'customize' option is not available when already " +
                "using a customized babel-loader wrapper.",
            );
          }
          let override = require(loaderOptions.customize);
          if (override.__esModule) override = override.default;
          if (typeof override !== "function") {
            throw new Error("Custom overrides must be functions.");
          }
          overrides = override(babel);
        }
        let customOptions;
        if (overrides && overrides.customOptions) {
          const result = await overrides.customOptions.call(
            this,
            loaderOptions,
            { source, map: inputSourceMap },
          );
          customOptions = result.custom;
          loaderOptions = result.loader;
        }
        if ("forceEnv" in loaderOptions) {
          console.warn(
            "The option `forceEnv` has been removed in favor of `envName` in Babel 7.",
          );
        }
        if (typeof loaderOptions.babelrc === "string") {
          console.warn(
            "The option `babelrc` should not be set to a string anymore in the babel-loader config. " +
              "Please update your configuration and set `babelrc` to true or false.\n" +
              "If you want to specify a specific babel config file to inherit config from " +
              "please use the `extends` option.\nFor more information about this options see " +
              "https://babeljs.io/docs/core-packages/#options",
          );
        }
        if (
          Object.prototype.hasOwnProperty.call(loaderOptions, "sourceMap") &&
          !Object.prototype.hasOwnProperty.call(loaderOptions, "sourceMaps")
        ) {
          loaderOptions = Object.assign({}, loaderOptions, {
            sourceMaps: loaderOptions.sourceMap,
          });
          delete loaderOptions.sourceMap;
        }
        const programmaticOptions = Object.assign({}, loaderOptions, {
          filename,
          inputSourceMap: inputSourceMap || loaderOptions.inputSourceMap,
          sourceMaps:
            loaderOptions.sourceMaps === undefined
              ? this.sourceMap
              : loaderOptions.sourceMaps,
          sourceFileName: filename,
        });
        delete programmaticOptions.customize;
        delete programmaticOptions.cacheDirectory;
        delete programmaticOptions.cacheIdentifier;
        delete programmaticOptions.cacheCompression;
        delete programmaticOptions.metadataSubscribers;
        const config = await babel.loadPartialConfigAsync(
          injectCaller(programmaticOptions, this.target),
        );
        if (config) {
          let options = config.options;
          if (overrides && overrides.config) {
            options = await overrides.config.call(this, config, {
              source,
              map: inputSourceMap,
              customOptions,
            });
          }
          if (options.sourceMaps === "inline") {
            options.sourceMaps = true;
          }
          const {
            cacheDirectory = null,
            cacheIdentifier = JSON.stringify({
              options,
              "@babel/core": transform.version,
              "@babel/loader": version,
            }),
            cacheCompression = true,
            metadataSubscribers = [],
          } = loaderOptions;
          let result;
          if (cacheDirectory) {
            result = await cache({
              source,
              options,
              transform,
              cacheDirectory,
              cacheIdentifier,
              cacheCompression,
            });
          } else {
            result = await transform(source, options);
          }
          config.files.forEach((configFile) => this.addDependency(configFile));
          if (result) {
            if (overrides && overrides.result) {
              result = await overrides.result.call(this, result, {
                source,
                map: inputSourceMap,
                customOptions,
                config,
                options,
              });
            }
            const { code, map, metadata, externalDependencies } = result;
            externalDependencies == null
              ? void 0
              : externalDependencies.forEach((dep) => this.addDependency(dep));
            metadataSubscribers.forEach((subscriber) => {
              subscribe(subscriber, metadata, this);
            });
            return [code, map];
          }
        }
        return [source, inputSourceMap];
      }
    },
    632: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const babel = __nccwpck_require__(718);
      module.exports = function injectCaller(opts, target) {
        if (!supportsCallerOption()) return opts;
        return Object.assign({}, opts, {
          caller: Object.assign(
            {
              name: "babel-loader",
              target,
              supportsStaticESM: true,
              supportsDynamicImport: true,
              supportsTopLevelAwait: true,
            },
            opts.caller,
          ),
        });
      };
      let supportsCallerOptionFlag = undefined;
      function supportsCallerOption() {
        if (supportsCallerOptionFlag === undefined) {
          try {
            babel.loadPartialConfig({
              caller: undefined,
              babelrc: false,
              configFile: false,
            });
            supportsCallerOptionFlag = true;
          } catch (err) {
            supportsCallerOptionFlag = false;
          }
        }
        return supportsCallerOptionFlag;
      }
    },
    982: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const babel = __nccwpck_require__(718);
      const { promisify } = __nccwpck_require__(837);
      const LoaderError = __nccwpck_require__(722);
      const transform = promisify(babel.transform);
      module.exports = async function (source, options) {
        let result;
        try {
          result = await transform(source, options);
        } catch (err) {
          throw err.message && err.codeFrame ? new LoaderError(err) : err;
        }
        if (!result) return null;
        const { ast, code, map, metadata, sourceType, externalDependencies } =
          result;
        if (map && (!map.sourcesContent || !map.sourcesContent.length)) {
          map.sourcesContent = [source];
        }
        return {
          ast,
          code,
          map,
          metadata,
          sourceType,
          externalDependencies: Array.from(externalDependencies || []),
        };
      };
      module.exports.version = babel.version;
    },
    684: (module) => {
      "use strict";
      module.exports = require("./package.json");
    },
    14: (module) => {
      "use strict";
      module.exports = require("./schema-utils");
    },
    718: (module) => {
      "use strict";
      module.exports = require("@babel/core");
    },
    113: (module) => {
      "use strict";
      module.exports = require("crypto");
    },
    292: (module) => {
      "use strict";
      module.exports = require("fs/promises");
    },
    561: (module) => {
      "use strict";
      module.exports = require("node:fs");
    },
    411: (module) => {
      "use strict";
      module.exports = require("node:path");
    },
    742: (module) => {
      "use strict";
      module.exports = require("node:process");
    },
    41: (module) => {
      "use strict";
      module.exports = require("node:url");
    },
    37: (module) => {
      "use strict";
      module.exports = require("os");
    },
    17: (module) => {
      "use strict";
      module.exports = require("path");
    },
    837: (module) => {
      "use strict";
      module.exports = require("util");
    },
    796: (module) => {
      "use strict";
      module.exports = require("zlib");
    },
    547: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"type":"object","properties":{"cacheDirectory":{"oneOf":[{"type":"boolean"},{"type":"string"}],"default":false},"cacheIdentifier":{"type":"string"},"cacheCompression":{"type":"boolean","default":true},"customize":{"type":"string","default":null}},"additionalProperties":true}',
      );
    },
  };
  var __webpack_module_cache__ = {};
  function __nccwpck_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (__webpack_module_cache__[moduleId] = { exports: {} });
    var threw = true;
    try {
      __webpack_modules__[moduleId](
        module,
        module.exports,
        __nccwpck_require__,
      );
      threw = false;
    } finally {
      if (threw) delete __webpack_module_cache__[moduleId];
    }
    return module.exports;
  }
  __nccwpck_require__.m = __webpack_modules__;
  (() => {
    __nccwpck_require__.d = (exports, definition) => {
      for (var key in definition) {
        if (
          __nccwpck_require__.o(definition, key) &&
          !__nccwpck_require__.o(exports, key)
        ) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
        }
      }
    };
  })();
  (() => {
    __nccwpck_require__.f = {};
    __nccwpck_require__.e = (chunkId) =>
      Promise.all(
        Object.keys(__nccwpck_require__.f).reduce((promises, key) => {
          __nccwpck_require__.f[key](chunkId, promises);
          return promises;
        }, []),
      );
  })();
  (() => {
    __nccwpck_require__.u = (chunkId) => "" + chunkId + ".index.js";
  })();
  (() => {
    __nccwpck_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  (() => {
    __nccwpck_require__.r = (exports) => {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      }
      Object.defineProperty(exports, "__esModule", { value: true });
    };
  })();
  if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  (() => {
    var installedChunks = { 179: 1 };
    var installChunk = (chunk) => {
      var moreModules = chunk.modules,
        chunkIds = chunk.ids,
        runtime = chunk.runtime;
      for (var moduleId in moreModules) {
        if (__nccwpck_require__.o(moreModules, moduleId)) {
          __nccwpck_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if (runtime) runtime(__nccwpck_require__);
      for (var i = 0; i < chunkIds.length; i++)
        installedChunks[chunkIds[i]] = 1;
    };
    __nccwpck_require__.f.require = (chunkId, promises) => {
      if (!installedChunks[chunkId]) {
        if (true) {
          installChunk(require("./" + __nccwpck_require__.u(chunkId)));
        } else installedChunks[chunkId] = 1;
      }
    };
  })();
  var __webpack_exports__ = __nccwpck_require__(767);
  module.exports = __webpack_exports__;
})();
