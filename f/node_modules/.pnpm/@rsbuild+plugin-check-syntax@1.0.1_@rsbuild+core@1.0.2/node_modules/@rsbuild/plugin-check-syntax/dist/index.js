// src/CheckSyntaxPlugin.ts
import fs3 from "node:fs";
import { resolve } from "node:path";
import { parse } from "acorn";
import { browserslistToESVersion } from "browserslist-to-es-version";

// src/generateError.ts
import fs from "node:fs";
import color from "picocolors";
import { SourceMapConsumer } from "source-map";

// src/types.ts
var ECMASyntaxError = class extends Error {
  constructor(message, options) {
    super(message);
    this.source = options.source;
    this.output = options.output;
  }
};

// src/utils.ts
function checkIsExcludeSource(path, exclude) {
  if (!exclude) {
    return false;
  }
  const excludes = Array.isArray(exclude) ? exclude : [exclude];
  return excludes.some((reg) => reg.test(path));
}

// src/generateError.ts
function displayCodePointer(code, pos) {
  const SUB_LEN = 80;
  const start = Math.max(pos - SUB_LEN / 2, 0);
  const subCode = code.slice(start, start + SUB_LEN);
  const arrowPos = pos - start;
  const arrowLine = color.yellow("^".padStart(arrowPos + 11, " "));
  return `${subCode}
${arrowLine}`;
}
async function generateError({
  err,
  code,
  filepath,
  rootPath,
  exclude
}) {
  let error = await tryGenerateErrorFromSourceMap({
    err,
    filepath,
    rootPath
  });
  if (!error) {
    const path = filepath.replace(rootPath, "");
    error = new ECMASyntaxError(err.message, {
      source: {
        path,
        line: err.loc.line,
        column: err.loc.column,
        code: displayCodePointer(code, err.pos)
      }
    });
  }
  if (checkIsExcludeSource(error.source.path, exclude)) {
    return null;
  }
  return error;
}
function makeCodeFrame(lines, highlightIndex) {
  const startLine = Math.max(highlightIndex - 3, 0);
  const endLine = Math.min(highlightIndex + 4, lines.length - 1);
  const ret = [];
  for (let i = startLine; i < endLine; i++) {
    if (i === highlightIndex) {
      const lineNumber = `> ${i + 1}`.padStart(6, " ");
      ret.push(color.yellow(`${lineNumber} | ${lines[i]}`));
    } else {
      const lineNumber = ` ${i + 1}`.padStart(6, " ");
      ret.push(color.gray(`${lineNumber} | ${lines[i]}`));
    }
  }
  return `
${ret.join("\n")}`;
}
async function tryGenerateErrorFromSourceMap({
  err,
  filepath,
  rootPath
}) {
  const sourceMapPath = `${filepath}.map`;
  if (!fs.existsSync(sourceMapPath)) {
    return null;
  }
  try {
    const sourcemap = await fs.promises.readFile(sourceMapPath, "utf-8");
    const consumer = await new SourceMapConsumer(sourcemap);
    const sm = consumer.originalPositionFor({
      line: err.loc.line,
      column: err.loc.column
    });
    if (!sm.source) {
      return null;
    }
    const { sources } = consumer;
    const smIndex = sources.indexOf(sm.source);
    const smContent = JSON.parse(sourcemap)?.sourcesContent?.[smIndex];
    if (!smContent) {
      return null;
    }
    const path = sm.source.replace(/webpack:\/\/(tmp)?/g, "");
    const relativeFilepath = filepath.replace(rootPath, "");
    const rawLines = smContent.split(/\r?\n/g);
    const highlightLine = (sm.line ?? 1) - 1;
    return new ECMASyntaxError(err.message, {
      source: {
        path,
        line: sm.line ?? 0,
        column: sm.column ?? 0,
        code: makeCodeFrame(rawLines, highlightLine)
      },
      output: {
        path: relativeFilepath,
        line: err.loc.line,
        column: err.loc.column
      }
    });
  } catch (e) {
    return null;
  }
}

// src/generateHtmlScripts.ts
import fs2 from "node:fs";
import { Parser } from "htmlparser2";
async function generateHtmlScripts(filepath) {
  const html = await fs2.promises.readFile(filepath, "utf-8");
  return getHtmlScripts(html);
}
function getHtmlScripts(html) {
  const inlineScripts = [];
  let currentScript = null;
  const parser = new Parser({
    onopentag(name, attrs) {
      if (name === "script" && !attrs.src && (!attrs.type || attrs.type === "application/javascript" || attrs.type === "text/javascript")) {
        currentScript = "";
      }
    },
    ontext(text) {
      if (currentScript !== null) {
        currentScript += text;
      }
    },
    onclosetag(tagname) {
      if (tagname === "script" && currentScript) {
        inlineScripts.push(currentScript.trim());
      }
      currentScript = null;
    }
  });
  parser.write(html);
  parser.end();
  return inlineScripts;
}

// src/printErrors.ts
import { logger } from "@rsbuild/core";
import color2 from "picocolors";
function printErrors(errors, ecmaVersion) {
  if (errors.length === 0) {
    logger.success("[@rsbuild/plugin-check-syntax] Syntax check passed.");
    return;
  }
  const errs = errors.map((error) => ({
    source: `${error.source.path}:${error.source.line}:${error.source.column}`,
    output: error.output ? `${error.output.path}:${error.output.line}:${error.output.column}` : void 0,
    reason: error.message,
    code: error.source.code
  }));
  const longest = Math.max(...Object.keys(errs[0]).map((err) => err.length));
  const expectedVersion = color2.yellow(`ecmaVersion <= ${ecmaVersion}`);
  logger.error(
    `[@rsbuild/plugin-check-syntax] Find some syntax that does not match "${expectedVersion}":
`
  );
  errs.forEach((err, index) => {
    console.log(color2.bold(color2.red(`  ERROR ${index + 1}`)));
    printMain(err, longest);
  });
  throw new Error(
    `[@rsbuild/plugin-check-syntax] The current build fails due to an incompatible syntax, which can be fixed in the following ways:

  - If you want to downgrade the syntax, you can compile the specified module through the \`source.include\` config.
  - If you don't want to downgrade the syntax, you can adjust the project's browserslist to match the syntax.
  - If you don't want to check the syntax of specified files, you can use the \`exclude\` option to exclude the files to be checked.
`
  );
}
function printMain(error, longest) {
  const fillWhiteSpace = (s, longest2) => {
    if (s.length < longest2) {
      const rightPadding = " ".repeat(longest2 - s.length);
      return s + rightPadding;
    }
    return s;
  };
  for (const [key, content] of Object.entries(error)) {
    if (!content) {
      continue;
    }
    const title = color2.magenta(`${fillWhiteSpace(`${key}:`, longest + 1)}`);
    console.info(`  ${title}  ${content}`);
  }
  console.info("");
}

// src/CheckSyntaxPlugin.ts
var HTML_REGEX = /\.html$/;
var JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
var CheckSyntaxPlugin = class _CheckSyntaxPlugin {
  constructor(options) {
    this.errors = [];
    this.targets = options.targets;
    this.exclude = options.exclude;
    this.rootPath = options.rootPath;
    this.ecmaVersion = options.ecmaVersion || browserslistToESVersion(this.targets);
  }
  apply(compiler) {
    compiler.hooks.afterEmit.tapPromise(
      _CheckSyntaxPlugin.name,
      async (compilation) => {
        const outputPath = compilation.outputOptions.path || "dist";
        const emittedAssets = compilation.getAssets().filter((a) => a.source).map((a) => {
          const resourcePath = a.name.split("?")[0];
          return resolve(outputPath, resourcePath);
        });
        const files = emittedAssets.filter(
          (assets) => HTML_REGEX.test(assets) || JS_REGEX.test(assets)
        );
        await Promise.all(
          files.map(async (file) => {
            await this.check(file);
          })
        );
        printErrors(this.errors, this.ecmaVersion);
      }
    );
  }
  async check(filepath) {
    if (HTML_REGEX.test(filepath)) {
      const htmlScripts = await generateHtmlScripts(filepath);
      await Promise.all(
        htmlScripts.map(async (script) => {
          if (!checkIsExcludeSource(filepath, this.exclude)) {
            await this.tryParse(filepath, script);
          }
        })
      );
    }
    if (JS_REGEX.test(filepath)) {
      const jsScript = await fs3.promises.readFile(filepath, "utf-8");
      await this.tryParse(filepath, jsScript);
    }
  }
  async tryParse(filepath, code) {
    try {
      parse(code, { ecmaVersion: this.ecmaVersion });
    } catch (_) {
      const err = _;
      const error = await generateError({
        err,
        code,
        filepath,
        exclude: this.exclude,
        rootPath: this.rootPath
      });
      if (error) {
        this.errors.push(error);
      }
    }
  }
};

// src/index.ts
var PLUGIN_CHECK_SYNTAX_NAME = "rsbuild:check-syntax";
function pluginCheckSyntax(options = {}) {
  return {
    name: PLUGIN_CHECK_SYNTAX_NAME,
    setup(api) {
      api.modifyBundlerChain(async (chain, { isDev, target, environment }) => {
        if (isDev || target !== "web") {
          return;
        }
        const { rootPath } = api.context;
        const targets = options.targets ?? environment.browserslist;
        chain.plugin(CheckSyntaxPlugin.name).use(CheckSyntaxPlugin, [
          {
            targets,
            rootPath,
            ...typeof options === "object" ? options : {}
          }
        ]);
      });
    }
  };
}
export {
  PLUGIN_CHECK_SYNTAX_NAME,
  pluginCheckSyntax
};
