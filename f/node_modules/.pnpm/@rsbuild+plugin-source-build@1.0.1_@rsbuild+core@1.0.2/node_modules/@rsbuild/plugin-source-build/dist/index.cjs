"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PLUGIN_SOURCE_BUILD_NAME: () => PLUGIN_SOURCE_BUILD_NAME,
  Project: () => Project,
  getMonorepoBaseData: () => getMonorepoBaseData,
  getMonorepoSubProjects: () => getMonorepoSubProjects,
  pluginSourceBuild: () => pluginSourceBuild
});
module.exports = __toCommonJS(src_exports);

// src/plugin.ts
var import_node_fs6 = __toESM(require("fs"), 1);
var import_node_path8 = __toESM(require("path"), 1);
var import_json52 = __toESM(require("json5"), 1);

// src/project-utils/getDependentProjects.ts
var import_node_fs5 = __toESM(require("fs"), 1);
var import_node_path7 = __toESM(require("path"), 1);

// src/common/getBaseData.ts
var import_node_path2 = __toESM(require("path"), 1);

// src/common/isMonorepo.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);

// src/constants.ts
var PNPM_WORKSPACE_FILE = "pnpm-workspace.yaml";
var RUSH_JSON_FILE = "rush.json";
var PACKAGE_JSON = "package.json";

// src/common/isMonorepo.ts
async function pathExists(path9) {
  return import_node_fs.default.promises.access(path9).then(() => true).catch(() => false);
}
var isPnpmMonorepo = async (monorepoRootPath) => {
  const existPnpmWorkspaceFile = await pathExists(
    import_node_path.default.join(monorepoRootPath, PNPM_WORKSPACE_FILE)
  );
  return existPnpmWorkspaceFile;
};
var isRushMonorepo = async (monorepoRootPath) => {
  const existRushJsonFile = await pathExists(
    import_node_path.default.join(monorepoRootPath, RUSH_JSON_FILE)
  );
  return existRushJsonFile;
};
var isMonorepo = async (monorepoRootPath, otherMonorepoChecks) => {
  if (typeof otherMonorepoChecks === "object") {
    for (const [monorepoType, monorepoCheck] of Object.entries(
      otherMonorepoChecks
    )) {
      if (typeof monorepoCheck === "function" && await monorepoCheck(monorepoRootPath)) {
        return {
          isMonorepo: true,
          type: monorepoType
        };
      }
    }
  }
  if (await isPnpmMonorepo(monorepoRootPath)) {
    return {
      isMonorepo: true,
      type: "pnpm"
    };
  }
  if (await isRushMonorepo(monorepoRootPath)) {
    return {
      isMonorepo: true,
      type: "rush"
    };
  }
  return {
    isMonorepo: false,
    type: ""
  };
};

// src/common/getBaseData.ts
var getMonorepoBaseData = async (starFindPath, otherMonorepoAnalyzer) => {
  let repoIsMonorepo = false;
  let findPath = starFindPath;
  let type = "";
  let otherMonorepoChecks;
  if (otherMonorepoAnalyzer) {
    otherMonorepoChecks = otherMonorepoChecks ?? {};
    for (const [monoType, analyzer] of Object.entries(otherMonorepoAnalyzer)) {
      otherMonorepoChecks[monoType] = analyzer.check;
    }
  }
  while (true) {
    const result = await isMonorepo(findPath, otherMonorepoChecks);
    if (result.isMonorepo) {
      repoIsMonorepo = true;
      ({ type } = result);
      break;
    }
    if (findPath === import_node_path2.default.dirname(findPath)) {
      break;
    }
    findPath = import_node_path2.default.dirname(findPath);
  }
  return {
    isMonorepo: repoIsMonorepo,
    rootPath: repoIsMonorepo ? findPath : "",
    type,
    getProjects: otherMonorepoAnalyzer?.[type]?.getProjects
  };
};

// src/common/pnpm.ts
var import_node_fs4 = __toESM(require("fs"), 1);
var import_node_path5 = __toESM(require("path"), 1);
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/project.ts
var import_node_fs3 = __toESM(require("fs"), 1);
var import_node_path4 = __toESM(require("path"), 1);

// src/utils.ts
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_path3 = __toESM(require("path"), 1);
var import_json5 = __toESM(require("json5"), 1);
var readPackageJson = async (pkgJsonFilePath) => {
  return readJson(pkgJsonFilePath);
};
var readRushJson = async (rushJsonFilePath) => {
  const rushJson = readJson(
    rushJsonFilePath.includes(RUSH_JSON_FILE) ? rushJsonFilePath : import_node_path3.default.join(rushJsonFilePath, RUSH_JSON_FILE)
  );
  return rushJson;
};
async function pathExists2(path9) {
  return import_node_fs2.default.promises.access(path9).then(() => true).catch(() => false);
}
var readJson = async (jsonFileAbsPath) => {
  if (!await pathExists2(jsonFileAbsPath)) {
    return {};
  }
  const content = await import_node_fs2.default.promises.readFile(jsonFileAbsPath, "utf-8");
  const json = import_json5.default.parse(content);
  return json;
};

// src/project.ts
var Project = class {
  constructor(name, dir) {
    this.name = name;
    this.dir = dir;
  }
  async init() {
    this.metaData = await readPackageJson(import_node_path4.default.join(this.dir, PACKAGE_JSON));
  }
  getMetaData() {
    if (this.metaData === null) {
      throw new Error(
        "The Project object needs to be initialized by executing the `init` function"
      );
    }
    return this.metaData;
  }
  getDependentProjects(monorepoProjects, options) {
    const { recursive } = options ?? { recursive: false };
    const allProjectMap = /* @__PURE__ */ new Map();
    for (const project of monorepoProjects) {
      allProjectMap.set(project.name, project);
    }
    if (!recursive) {
      return this.getDirectDependentProjects(allProjectMap);
    }
    const computedSet = /* @__PURE__ */ new Set();
    computedSet.add(this.name);
    const queue = this.getDirectDependentProjects(allProjectMap).filter(
      (p) => !computedSet.has(p.name)
    );
    const result = [];
    while (queue.length > 0) {
      const item = queue.shift();
      if (computedSet.has(item.name)) {
        continue;
      }
      result.push(item);
      computedSet.add(item.name);
      const newDeps = item.getDirectDependentProjects(allProjectMap);
      if (newDeps.length > 0) {
        queue.push(...newDeps);
      }
    }
    return result;
  }
  getDirectDependentProjects(allProjectMap) {
    const pkgJson = this.getMetaData();
    const { dependencies = {}, devDependencies = {} } = pkgJson;
    const projects = [];
    for (const d of Object.keys(dependencies)) {
      if (allProjectMap.has(d)) {
        projects.push(allProjectMap.get(d));
      }
    }
    for (const d of Object.keys(devDependencies)) {
      if (allProjectMap.has(d)) {
        projects.push(allProjectMap.get(d));
      }
    }
    return projects;
  }
  getSourceEntryPaths(options) {
    const { exports: checkExports = false, field: sourceField = "source" } = options ?? {};
    const pkgJson = this.getMetaData();
    const sourceDirs = pkgJson[sourceField] ? [import_node_path4.default.normalize(pkgJson[sourceField])] : [];
    if (checkExports) {
      const exportsSourceDirs = this.#getExportsSourceDirs(
        pkgJson.exports ?? {},
        sourceField
      );
      sourceDirs.push(...exportsSourceDirs);
    }
    if (!sourceDirs.length) {
      throw new Error(
        `"${sourceField}" field is not found in ${this.name} package.json`
      );
    }
    return this.#getCommonRootPaths(sourceDirs);
  }
  #getExportsSourceDirs(exportsConfig, sourceField) {
    const exportsSourceDirs = [];
    if (typeof exportsConfig[sourceField] === "string") {
      exportsSourceDirs.push(
        import_node_path4.default.normalize(exportsConfig[sourceField])
      );
    }
    for (const moduleRules of Object.values(exportsConfig)) {
      if (typeof moduleRules === "object" && typeof moduleRules[sourceField] === "string") {
        exportsSourceDirs.push(
          import_node_path4.default.normalize(moduleRules[sourceField])
        );
      }
    }
    return exportsSourceDirs;
  }
  /**
   *
   * @param paths normalize paths
   * @returns common root paths
   */
  #getCommonRootPaths(paths) {
    const commonRootPathsSet = /* @__PURE__ */ new Set();
    for (const p of paths) {
      let dir;
      try {
        dir = import_node_fs3.default.statSync(p).isDirectory() ? p : import_node_path4.default.dirname(p);
      } catch {
        dir = import_node_path4.default.dirname(p);
      }
      const rootPath = this.#getRootPath(dir);
      if (!commonRootPathsSet.has(rootPath)) {
        commonRootPathsSet.add(rootPath);
      }
    }
    return Array.from(commonRootPathsSet).map((p) => import_node_path4.default.join(this.dir, p));
  }
  #getRootPath(p) {
    return p.split(import_node_path4.default.sep)[0];
  }
};

// src/common/pnpm.ts
var getPatternsFromYaml = async (monorepoRoot) => {
  const { parse } = await import("yaml");
  const workspaceYamlFilePath = import_node_path5.default.join(monorepoRoot, PNPM_WORKSPACE_FILE);
  const yamlContent = await import_node_fs4.default.promises.readFile(workspaceYamlFilePath, "utf8");
  const pnpmWorkspace = parse(yamlContent);
  return pnpmWorkspace.packages || [];
};
var normalize = (results) => results.map((fp) => import_node_path5.default.normalize(fp));
var getGlobOpts = (rootPath, patterns) => {
  const globOpts = {
    cwd: rootPath,
    absolute: true,
    followSymbolicLinks: false
  };
  if (patterns.some((cfg) => cfg.includes("**") || cfg.includes("*"))) {
    globOpts.ignore = [
      // allow globs like "packages/**" or "packages/*",
      // but avoid picking up node_modules/**/package.json and dist/**/package.json
      "**/dist/**",
      "**/node_modules/**"
    ];
  }
  return globOpts;
};
var makeFileFinder = (rootPath, patterns) => {
  const globOpts = getGlobOpts(rootPath, patterns);
  return async (fileName, fileMapper) => {
    let result = await (0, import_fast_glob.default)(
      patterns.map((globPath) => import_node_path5.default.posix.join(globPath, fileName)),
      globOpts
    );
    result = result.sort();
    result = normalize(result);
    return fileMapper(result);
  };
};
var readPnpmProjects = async (monorepoRoot, patterns) => {
  const finder = makeFileFinder(monorepoRoot, patterns);
  const mapper = async (pkgJsonFilePath) => {
    const pkgJson = await readPackageJson(pkgJsonFilePath);
    return {
      dir: import_node_path5.default.dirname(pkgJsonFilePath),
      manifest: pkgJson
    };
  };
  const projects = await finder(
    PACKAGE_JSON,
    (filePaths) => Promise.all(filePaths.map(mapper))
  );
  return projects;
};
var getProjects = async (monorepoRoot) => {
  const patterns = await getPatternsFromYaml(monorepoRoot);
  const pnpmProjects = await readPnpmProjects(monorepoRoot, patterns);
  return Promise.all(
    pnpmProjects.filter((p) => p.manifest.name).map(async (p) => {
      const project = new Project(p.manifest.name, p.dir);
      await project.init();
      return project;
    })
  );
};

// src/common/rush.ts
var import_node_path6 = __toESM(require("path"), 1);
var getProjects2 = async (monorepoRoot) => {
  const rushConfiguration = await readRushJson(monorepoRoot);
  const { projects = [] } = rushConfiguration;
  return Promise.all(
    projects.map(async (p) => {
      const project = new Project(
        p.packageName,
        import_node_path6.default.join(monorepoRoot, p.projectFolder)
      );
      await project.init();
      return project;
    })
  );
};

// src/common/getProjects.ts
var getMonorepoSubProjects = async (monorepoBaseData) => {
  const { type, rootPath, getProjects: getProjects3 } = monorepoBaseData;
  if (type === "pnpm") {
    return getProjects(rootPath);
  }
  if (type === "rush") {
    return getProjects2(rootPath);
  }
  if (getProjects3) {
    return getProjects3(rootPath);
  }
  return [];
};

// src/project-utils/getDependentProjects.ts
async function pathExists3(path9) {
  return import_node_fs5.default.promises.access(path9).then(() => true).catch(() => false);
}
var getDependentProjects = async (projectNameOrRootPath, options) => {
  const {
    cwd = process.cwd(),
    recursive,
    filter,
    extraMonorepoStrategies
  } = options;
  const currentProjectPkgJsonPath = import_node_path7.default.join(
    projectNameOrRootPath,
    "package.json"
  );
  let projectName;
  if (await pathExists3(currentProjectPkgJsonPath)) {
    ({ name: projectName } = await readPackageJson(currentProjectPkgJsonPath));
  } else {
    projectName = projectNameOrRootPath;
  }
  const monoBaseData = await getMonorepoBaseData(cwd, extraMonorepoStrategies);
  if (!monoBaseData.isMonorepo) {
    return [];
  }
  const projects = await getMonorepoSubProjects(monoBaseData);
  const currentProject = projects.find(
    (project) => project.name === projectName
  );
  if (!currentProject) {
    return [];
  }
  let dependentProjects = currentProject.getDependentProjects(projects, {
    recursive
  });
  if (filter) {
    dependentProjects = await filter(dependentProjects);
  }
  return dependentProjects;
};

// src/project-utils/filter.ts
function hasExportsSourceField(exportsConfig, sourceField) {
  return typeof exportsConfig[sourceField] === "string" || Object.values(exportsConfig).some(
    (moduleRules) => typeof moduleRules === "object" && typeof moduleRules[sourceField] === "string"
  );
}
var filterByField = (fieldName, checkExports) => (projects) => {
  return projects.filter((p) => {
    return fieldName in p.metaData || checkExports && hasExportsSourceField(p.metaData.exports || {}, fieldName);
  });
};

// src/plugin.ts
var PLUGIN_SOURCE_BUILD_NAME = "rsbuild:source-build";
var getSourceInclude = async (options) => {
  const { projects, sourceField } = options;
  const includes = [];
  for (const project of projects) {
    includes.push(
      ...project.getSourceEntryPaths({ field: sourceField, exports: true })
    );
  }
  return includes;
};
function pluginSourceBuild(options) {
  const {
    projectName,
    sourceField = "source",
    resolvePriority = "source",
    extraMonorepoStrategies
  } = options ?? {};
  return {
    name: PLUGIN_SOURCE_BUILD_NAME,
    setup(api) {
      const projectRootPath = api.context.rootPath;
      let projects;
      api.modifyEnvironmentConfig(async (config) => {
        projects = projects || await getDependentProjects(projectName || projectRootPath, {
          cwd: projectRootPath,
          recursive: true,
          filter: filterByField(sourceField, true),
          extraMonorepoStrategies
        });
        const includes = await getSourceInclude({
          projects,
          sourceField
        });
        config.source = config.source ?? {};
        config.source.include = [...config.source.include ?? [], ...includes];
      });
      api.modifyBundlerChain((chain, { CHAIN_ID }) => {
        for (const ruleId of [CHAIN_ID.RULE.TS, CHAIN_ID.RULE.JS]) {
          if (chain.module.rules.get(ruleId)) {
            const rule = chain.module.rule(ruleId);
            rule.resolve.mainFields.merge(
              resolvePriority === "source" ? [sourceField, "..."] : ["...", sourceField]
            );
            rule.resolve.conditionNames.add("...").add(sourceField);
          }
        }
      });
      const getReferences = async (tsconfigPath, rspackReferences) => {
        const references = /* @__PURE__ */ new Set();
        for (const project of projects || []) {
          const filePath = import_node_path8.default.join(project.dir, "tsconfig.json");
          if (import_node_fs6.default.existsSync(filePath)) {
            references.add(filePath);
          }
        }
        const tsconfig = import_json52.default.parse(
          import_node_fs6.default.readFileSync(tsconfigPath, "utf-8")
        );
        const userReferences = [
          ...Array.isArray(rspackReferences) ? rspackReferences : [],
          ...tsconfig.references ? tsconfig.references.map((item) => item.path).filter(Boolean) : []
        ];
        if (userReferences.length) {
          const baseDir = import_node_path8.default.dirname(tsconfigPath);
          for (const item of userReferences) {
            if (!item) {
              continue;
            }
            const absolutePath = import_node_path8.default.isAbsolute(item) ? item : import_node_path8.default.join(baseDir, item);
            references.add(absolutePath);
          }
        }
        references.delete(tsconfigPath);
        return Array.from(references);
      };
      if (api.context.bundlerType === "rspack") {
        api.modifyRspackConfig(async (config, { environment }) => {
          const { tsconfigPath } = environment;
          if (!tsconfigPath) {
            return;
          }
          config.resolve ||= {};
          const { tsConfig = { configFile: tsconfigPath } } = config.resolve;
          const configObject = typeof tsConfig === "string" ? { configFile: tsConfig } : tsConfig;
          const references = await getReferences(
            tsconfigPath,
            configObject.references
          );
          config.resolve.tsConfig = {
            configFile: configObject?.configFile || tsconfigPath,
            references
          };
        });
      } else {
        api.modifyBundlerChain(async (chain, { CHAIN_ID, environment }) => {
          const { TS_CONFIG_PATHS } = CHAIN_ID.RESOLVE_PLUGIN;
          const { tsconfigPath } = environment;
          if (!chain.resolve.plugins.has(TS_CONFIG_PATHS) || !tsconfigPath) {
            return;
          }
          const references = await getReferences(tsconfigPath);
          chain.resolve.plugin(TS_CONFIG_PATHS).tap(
            (options2) => options2.map((option) => ({
              ...option,
              references
            }))
          );
        });
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_SOURCE_BUILD_NAME,
  Project,
  getMonorepoBaseData,
  getMonorepoSubProjects,
  pluginSourceBuild
});
