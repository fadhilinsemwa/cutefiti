// src/plugin.ts
import fs6 from "node:fs";
import path8 from "node:path";
import json52 from "json5";

// src/project-utils/getDependentProjects.ts
import fs5 from "node:fs";
import path7 from "node:path";

// src/common/getBaseData.ts
import path2 from "node:path";

// src/common/isMonorepo.ts
import fs from "node:fs";
import path from "node:path";

// src/constants.ts
var PNPM_WORKSPACE_FILE = "pnpm-workspace.yaml";
var RUSH_JSON_FILE = "rush.json";
var PACKAGE_JSON = "package.json";

// src/common/isMonorepo.ts
async function pathExists(path9) {
  return fs.promises.access(path9).then(() => true).catch(() => false);
}
var isPnpmMonorepo = async (monorepoRootPath) => {
  const existPnpmWorkspaceFile = await pathExists(
    path.join(monorepoRootPath, PNPM_WORKSPACE_FILE)
  );
  return existPnpmWorkspaceFile;
};
var isRushMonorepo = async (monorepoRootPath) => {
  const existRushJsonFile = await pathExists(
    path.join(monorepoRootPath, RUSH_JSON_FILE)
  );
  return existRushJsonFile;
};
var isMonorepo = async (monorepoRootPath, otherMonorepoChecks) => {
  if (typeof otherMonorepoChecks === "object") {
    for (const [monorepoType, monorepoCheck] of Object.entries(
      otherMonorepoChecks
    )) {
      if (typeof monorepoCheck === "function" && await monorepoCheck(monorepoRootPath)) {
        return {
          isMonorepo: true,
          type: monorepoType
        };
      }
    }
  }
  if (await isPnpmMonorepo(monorepoRootPath)) {
    return {
      isMonorepo: true,
      type: "pnpm"
    };
  }
  if (await isRushMonorepo(monorepoRootPath)) {
    return {
      isMonorepo: true,
      type: "rush"
    };
  }
  return {
    isMonorepo: false,
    type: ""
  };
};

// src/common/getBaseData.ts
var getMonorepoBaseData = async (starFindPath, otherMonorepoAnalyzer) => {
  let repoIsMonorepo = false;
  let findPath = starFindPath;
  let type = "";
  let otherMonorepoChecks;
  if (otherMonorepoAnalyzer) {
    otherMonorepoChecks = otherMonorepoChecks ?? {};
    for (const [monoType, analyzer] of Object.entries(otherMonorepoAnalyzer)) {
      otherMonorepoChecks[monoType] = analyzer.check;
    }
  }
  while (true) {
    const result = await isMonorepo(findPath, otherMonorepoChecks);
    if (result.isMonorepo) {
      repoIsMonorepo = true;
      ({ type } = result);
      break;
    }
    if (findPath === path2.dirname(findPath)) {
      break;
    }
    findPath = path2.dirname(findPath);
  }
  return {
    isMonorepo: repoIsMonorepo,
    rootPath: repoIsMonorepo ? findPath : "",
    type,
    getProjects: otherMonorepoAnalyzer?.[type]?.getProjects
  };
};

// src/common/pnpm.ts
import fs4 from "node:fs";
import path5 from "node:path";
import glob from "fast-glob";

// src/project.ts
import fs3 from "node:fs";
import path4 from "node:path";

// src/utils.ts
import fs2 from "node:fs";
import path3 from "node:path";
import json5 from "json5";
var readPackageJson = async (pkgJsonFilePath) => {
  return readJson(pkgJsonFilePath);
};
var readRushJson = async (rushJsonFilePath) => {
  const rushJson = readJson(
    rushJsonFilePath.includes(RUSH_JSON_FILE) ? rushJsonFilePath : path3.join(rushJsonFilePath, RUSH_JSON_FILE)
  );
  return rushJson;
};
async function pathExists2(path9) {
  return fs2.promises.access(path9).then(() => true).catch(() => false);
}
var readJson = async (jsonFileAbsPath) => {
  if (!await pathExists2(jsonFileAbsPath)) {
    return {};
  }
  const content = await fs2.promises.readFile(jsonFileAbsPath, "utf-8");
  const json = json5.parse(content);
  return json;
};

// src/project.ts
var Project = class {
  constructor(name, dir) {
    this.name = name;
    this.dir = dir;
  }
  async init() {
    this.metaData = await readPackageJson(path4.join(this.dir, PACKAGE_JSON));
  }
  getMetaData() {
    if (this.metaData === null) {
      throw new Error(
        "The Project object needs to be initialized by executing the `init` function"
      );
    }
    return this.metaData;
  }
  getDependentProjects(monorepoProjects, options) {
    const { recursive } = options ?? { recursive: false };
    const allProjectMap = /* @__PURE__ */ new Map();
    for (const project of monorepoProjects) {
      allProjectMap.set(project.name, project);
    }
    if (!recursive) {
      return this.getDirectDependentProjects(allProjectMap);
    }
    const computedSet = /* @__PURE__ */ new Set();
    computedSet.add(this.name);
    const queue = this.getDirectDependentProjects(allProjectMap).filter(
      (p) => !computedSet.has(p.name)
    );
    const result = [];
    while (queue.length > 0) {
      const item = queue.shift();
      if (computedSet.has(item.name)) {
        continue;
      }
      result.push(item);
      computedSet.add(item.name);
      const newDeps = item.getDirectDependentProjects(allProjectMap);
      if (newDeps.length > 0) {
        queue.push(...newDeps);
      }
    }
    return result;
  }
  getDirectDependentProjects(allProjectMap) {
    const pkgJson = this.getMetaData();
    const { dependencies = {}, devDependencies = {} } = pkgJson;
    const projects = [];
    for (const d of Object.keys(dependencies)) {
      if (allProjectMap.has(d)) {
        projects.push(allProjectMap.get(d));
      }
    }
    for (const d of Object.keys(devDependencies)) {
      if (allProjectMap.has(d)) {
        projects.push(allProjectMap.get(d));
      }
    }
    return projects;
  }
  getSourceEntryPaths(options) {
    const { exports: checkExports = false, field: sourceField = "source" } = options ?? {};
    const pkgJson = this.getMetaData();
    const sourceDirs = pkgJson[sourceField] ? [path4.normalize(pkgJson[sourceField])] : [];
    if (checkExports) {
      const exportsSourceDirs = this.#getExportsSourceDirs(
        pkgJson.exports ?? {},
        sourceField
      );
      sourceDirs.push(...exportsSourceDirs);
    }
    if (!sourceDirs.length) {
      throw new Error(
        `"${sourceField}" field is not found in ${this.name} package.json`
      );
    }
    return this.#getCommonRootPaths(sourceDirs);
  }
  #getExportsSourceDirs(exportsConfig, sourceField) {
    const exportsSourceDirs = [];
    if (typeof exportsConfig[sourceField] === "string") {
      exportsSourceDirs.push(
        path4.normalize(exportsConfig[sourceField])
      );
    }
    for (const moduleRules of Object.values(exportsConfig)) {
      if (typeof moduleRules === "object" && typeof moduleRules[sourceField] === "string") {
        exportsSourceDirs.push(
          path4.normalize(moduleRules[sourceField])
        );
      }
    }
    return exportsSourceDirs;
  }
  /**
   *
   * @param paths normalize paths
   * @returns common root paths
   */
  #getCommonRootPaths(paths) {
    const commonRootPathsSet = /* @__PURE__ */ new Set();
    for (const p of paths) {
      let dir;
      try {
        dir = fs3.statSync(p).isDirectory() ? p : path4.dirname(p);
      } catch {
        dir = path4.dirname(p);
      }
      const rootPath = this.#getRootPath(dir);
      if (!commonRootPathsSet.has(rootPath)) {
        commonRootPathsSet.add(rootPath);
      }
    }
    return Array.from(commonRootPathsSet).map((p) => path4.join(this.dir, p));
  }
  #getRootPath(p) {
    return p.split(path4.sep)[0];
  }
};

// src/common/pnpm.ts
var getPatternsFromYaml = async (monorepoRoot) => {
  const { parse } = await import("yaml");
  const workspaceYamlFilePath = path5.join(monorepoRoot, PNPM_WORKSPACE_FILE);
  const yamlContent = await fs4.promises.readFile(workspaceYamlFilePath, "utf8");
  const pnpmWorkspace = parse(yamlContent);
  return pnpmWorkspace.packages || [];
};
var normalize = (results) => results.map((fp) => path5.normalize(fp));
var getGlobOpts = (rootPath, patterns) => {
  const globOpts = {
    cwd: rootPath,
    absolute: true,
    followSymbolicLinks: false
  };
  if (patterns.some((cfg) => cfg.includes("**") || cfg.includes("*"))) {
    globOpts.ignore = [
      // allow globs like "packages/**" or "packages/*",
      // but avoid picking up node_modules/**/package.json and dist/**/package.json
      "**/dist/**",
      "**/node_modules/**"
    ];
  }
  return globOpts;
};
var makeFileFinder = (rootPath, patterns) => {
  const globOpts = getGlobOpts(rootPath, patterns);
  return async (fileName, fileMapper) => {
    let result = await glob(
      patterns.map((globPath) => path5.posix.join(globPath, fileName)),
      globOpts
    );
    result = result.sort();
    result = normalize(result);
    return fileMapper(result);
  };
};
var readPnpmProjects = async (monorepoRoot, patterns) => {
  const finder = makeFileFinder(monorepoRoot, patterns);
  const mapper = async (pkgJsonFilePath) => {
    const pkgJson = await readPackageJson(pkgJsonFilePath);
    return {
      dir: path5.dirname(pkgJsonFilePath),
      manifest: pkgJson
    };
  };
  const projects = await finder(
    PACKAGE_JSON,
    (filePaths) => Promise.all(filePaths.map(mapper))
  );
  return projects;
};
var getProjects = async (monorepoRoot) => {
  const patterns = await getPatternsFromYaml(monorepoRoot);
  const pnpmProjects = await readPnpmProjects(monorepoRoot, patterns);
  return Promise.all(
    pnpmProjects.filter((p) => p.manifest.name).map(async (p) => {
      const project = new Project(p.manifest.name, p.dir);
      await project.init();
      return project;
    })
  );
};

// src/common/rush.ts
import path6 from "node:path";
var getProjects2 = async (monorepoRoot) => {
  const rushConfiguration = await readRushJson(monorepoRoot);
  const { projects = [] } = rushConfiguration;
  return Promise.all(
    projects.map(async (p) => {
      const project = new Project(
        p.packageName,
        path6.join(monorepoRoot, p.projectFolder)
      );
      await project.init();
      return project;
    })
  );
};

// src/common/getProjects.ts
var getMonorepoSubProjects = async (monorepoBaseData) => {
  const { type, rootPath, getProjects: getProjects3 } = monorepoBaseData;
  if (type === "pnpm") {
    return getProjects(rootPath);
  }
  if (type === "rush") {
    return getProjects2(rootPath);
  }
  if (getProjects3) {
    return getProjects3(rootPath);
  }
  return [];
};

// src/project-utils/getDependentProjects.ts
async function pathExists3(path9) {
  return fs5.promises.access(path9).then(() => true).catch(() => false);
}
var getDependentProjects = async (projectNameOrRootPath, options) => {
  const {
    cwd = process.cwd(),
    recursive,
    filter,
    extraMonorepoStrategies
  } = options;
  const currentProjectPkgJsonPath = path7.join(
    projectNameOrRootPath,
    "package.json"
  );
  let projectName;
  if (await pathExists3(currentProjectPkgJsonPath)) {
    ({ name: projectName } = await readPackageJson(currentProjectPkgJsonPath));
  } else {
    projectName = projectNameOrRootPath;
  }
  const monoBaseData = await getMonorepoBaseData(cwd, extraMonorepoStrategies);
  if (!monoBaseData.isMonorepo) {
    return [];
  }
  const projects = await getMonorepoSubProjects(monoBaseData);
  const currentProject = projects.find(
    (project) => project.name === projectName
  );
  if (!currentProject) {
    return [];
  }
  let dependentProjects = currentProject.getDependentProjects(projects, {
    recursive
  });
  if (filter) {
    dependentProjects = await filter(dependentProjects);
  }
  return dependentProjects;
};

// src/project-utils/filter.ts
function hasExportsSourceField(exportsConfig, sourceField) {
  return typeof exportsConfig[sourceField] === "string" || Object.values(exportsConfig).some(
    (moduleRules) => typeof moduleRules === "object" && typeof moduleRules[sourceField] === "string"
  );
}
var filterByField = (fieldName, checkExports) => (projects) => {
  return projects.filter((p) => {
    return fieldName in p.metaData || checkExports && hasExportsSourceField(p.metaData.exports || {}, fieldName);
  });
};

// src/plugin.ts
var PLUGIN_SOURCE_BUILD_NAME = "rsbuild:source-build";
var getSourceInclude = async (options) => {
  const { projects, sourceField } = options;
  const includes = [];
  for (const project of projects) {
    includes.push(
      ...project.getSourceEntryPaths({ field: sourceField, exports: true })
    );
  }
  return includes;
};
function pluginSourceBuild(options) {
  const {
    projectName,
    sourceField = "source",
    resolvePriority = "source",
    extraMonorepoStrategies
  } = options ?? {};
  return {
    name: PLUGIN_SOURCE_BUILD_NAME,
    setup(api) {
      const projectRootPath = api.context.rootPath;
      let projects;
      api.modifyEnvironmentConfig(async (config) => {
        projects = projects || await getDependentProjects(projectName || projectRootPath, {
          cwd: projectRootPath,
          recursive: true,
          filter: filterByField(sourceField, true),
          extraMonorepoStrategies
        });
        const includes = await getSourceInclude({
          projects,
          sourceField
        });
        config.source = config.source ?? {};
        config.source.include = [...config.source.include ?? [], ...includes];
      });
      api.modifyBundlerChain((chain, { CHAIN_ID }) => {
        for (const ruleId of [CHAIN_ID.RULE.TS, CHAIN_ID.RULE.JS]) {
          if (chain.module.rules.get(ruleId)) {
            const rule = chain.module.rule(ruleId);
            rule.resolve.mainFields.merge(
              resolvePriority === "source" ? [sourceField, "..."] : ["...", sourceField]
            );
            rule.resolve.conditionNames.add("...").add(sourceField);
          }
        }
      });
      const getReferences = async (tsconfigPath, rspackReferences) => {
        const references = /* @__PURE__ */ new Set();
        for (const project of projects || []) {
          const filePath = path8.join(project.dir, "tsconfig.json");
          if (fs6.existsSync(filePath)) {
            references.add(filePath);
          }
        }
        const tsconfig = json52.parse(
          fs6.readFileSync(tsconfigPath, "utf-8")
        );
        const userReferences = [
          ...Array.isArray(rspackReferences) ? rspackReferences : [],
          ...tsconfig.references ? tsconfig.references.map((item) => item.path).filter(Boolean) : []
        ];
        if (userReferences.length) {
          const baseDir = path8.dirname(tsconfigPath);
          for (const item of userReferences) {
            if (!item) {
              continue;
            }
            const absolutePath = path8.isAbsolute(item) ? item : path8.join(baseDir, item);
            references.add(absolutePath);
          }
        }
        references.delete(tsconfigPath);
        return Array.from(references);
      };
      if (api.context.bundlerType === "rspack") {
        api.modifyRspackConfig(async (config, { environment }) => {
          const { tsconfigPath } = environment;
          if (!tsconfigPath) {
            return;
          }
          config.resolve ||= {};
          const { tsConfig = { configFile: tsconfigPath } } = config.resolve;
          const configObject = typeof tsConfig === "string" ? { configFile: tsConfig } : tsConfig;
          const references = await getReferences(
            tsconfigPath,
            configObject.references
          );
          config.resolve.tsConfig = {
            configFile: configObject?.configFile || tsconfigPath,
            references
          };
        });
      } else {
        api.modifyBundlerChain(async (chain, { CHAIN_ID, environment }) => {
          const { TS_CONFIG_PATHS } = CHAIN_ID.RESOLVE_PLUGIN;
          const { tsconfigPath } = environment;
          if (!chain.resolve.plugins.has(TS_CONFIG_PATHS) || !tsconfigPath) {
            return;
          }
          const references = await getReferences(tsconfigPath);
          chain.resolve.plugin(TS_CONFIG_PATHS).tap(
            (options2) => options2.map((option) => ({
              ...option,
              references
            }))
          );
        });
      }
    }
  };
}
export {
  PLUGIN_SOURCE_BUILD_NAME,
  Project,
  getMonorepoBaseData,
  getMonorepoSubProjects,
  pluginSourceBuild
};
