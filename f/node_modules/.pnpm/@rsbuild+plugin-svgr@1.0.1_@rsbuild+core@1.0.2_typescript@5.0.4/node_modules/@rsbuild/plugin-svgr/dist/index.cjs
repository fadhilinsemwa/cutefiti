"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PLUGIN_SVGR_NAME: () => PLUGIN_SVGR_NAME,
  pluginSvgr: () => pluginSvgr
});
module.exports = __toCommonJS(src_exports);
var import_node_path = __toESM(require("path"));
var import_plugin_react = require("@rsbuild/plugin-react");
var import_deepmerge = __toESM(require("deepmerge"));
var SVG_REGEX = /\.svg$/;
var getSvgoDefaultConfig = () => ({
  plugins: [
    {
      name: "preset-default",
      params: {
        overrides: {
          // viewBox is required to resize SVGs with CSS.
          // @see https://github.com/svg/svgo/issues/1128
          removeViewBox: false
        }
      }
    },
    "prefixIds"
  ]
});
var dedupeSvgoPlugins = (config) => {
  if (!config.plugins) {
    return config;
  }
  let mergedPlugins = [];
  for (const plugin of config.plugins) {
    if (typeof plugin === "string") {
      const exist = mergedPlugins.find(
        (item) => item === plugin || typeof item === "object" && item.name === plugin
      );
      if (!exist) {
        mergedPlugins.push(plugin);
      }
      continue;
    }
    const strIndex = mergedPlugins.findIndex(
      (item) => typeof item === "string" && item === plugin.name
    );
    if (strIndex !== -1) {
      mergedPlugins[strIndex] = plugin;
      continue;
    }
    let isMerged = false;
    mergedPlugins = mergedPlugins.map((item) => {
      if (typeof item === "object" && item.name === plugin.name) {
        isMerged = true;
        return (0, import_deepmerge.default)(item, plugin);
      }
      return item;
    });
    if (!isMerged) {
      mergedPlugins.push(plugin);
    }
  }
  config.plugins = mergedPlugins;
  return config;
};
var PLUGIN_SVGR_NAME = "rsbuild:svgr";
var pluginSvgr = (options = {}) => ({
  name: PLUGIN_SVGR_NAME,
  pre: [import_plugin_react.PLUGIN_REACT_NAME],
  setup(api) {
    api.modifyBundlerChain(async (chain, { CHAIN_ID, environment }) => {
      const { config } = environment;
      const { dataUriLimit } = config.output;
      const maxSize = typeof dataUriLimit === "number" ? dataUriLimit : dataUriLimit.svg;
      let generatorOptions = {};
      if (chain.module.rules.has(CHAIN_ID.RULE.SVG)) {
        generatorOptions = chain.module.rules.get(CHAIN_ID.RULE.SVG).oneOfs.get(CHAIN_ID.ONE_OF.SVG_URL).get("generator");
        chain.module.rules.delete(CHAIN_ID.RULE.SVG);
      }
      const rule = chain.module.rule(CHAIN_ID.RULE.SVG).test(SVG_REGEX);
      const svgrOptions = (0, import_deepmerge.default)(
        {
          svgo: true,
          svgoConfig: getSvgoDefaultConfig()
        },
        options.svgrOptions || {}
      );
      svgrOptions.svgoConfig = dedupeSvgoPlugins(svgrOptions.svgoConfig);
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_URL).type("asset/resource").resourceQuery(/(__inline=false|url)/).set("generator", generatorOptions);
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_INLINE).type("asset/inline").resourceQuery(/inline/);
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_REACT).type("javascript/auto").resourceQuery(options.query || /react/).use(CHAIN_ID.USE.SVGR).loader(import_node_path.default.resolve(__dirname, "./loader.cjs")).options({
        ...svgrOptions,
        exportType: "default"
      }).end();
      const { mixedImport = false } = options;
      if (mixedImport || svgrOptions.exportType) {
        const { exportType = mixedImport ? "named" : void 0 } = svgrOptions;
        const issuerInclude = [
          /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/,
          /\.mdx$/
        ];
        const issuer = options.excludeImporter ? { and: [issuerInclude, { not: options.excludeImporter }] } : issuerInclude;
        const svgRule = rule.oneOf(CHAIN_ID.ONE_OF.SVG);
        if (options.exclude) {
          svgRule.exclude.add(options.exclude);
        }
        svgRule.type("javascript/auto").set("issuer", issuer).use(CHAIN_ID.USE.SVGR).loader(import_node_path.default.resolve(__dirname, "./loader.cjs")).options({
          ...svgrOptions,
          exportType
        }).end();
        if (mixedImport && exportType === "named") {
          svgRule.use(CHAIN_ID.USE.URL).loader(import_node_path.default.join(__dirname, "../compiled", "url-loader/index.js")).options({
            limit: maxSize,
            name: generatorOptions?.filename
          });
        }
      }
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_ASSET).type("asset").parser({
        // Inline SVG if size < maxSize
        dataUrlCondition: {
          maxSize
        }
      }).set("generator", generatorOptions);
      const jsRule = chain.module.rules.get(CHAIN_ID.RULE.JS);
      [CHAIN_ID.USE.SWC, CHAIN_ID.USE.BABEL].some((jsUseId) => {
        const use = jsRule.uses.get(jsUseId);
        if (!use) {
          return false;
        }
        for (const oneOfId of [
          CHAIN_ID.ONE_OF.SVG,
          CHAIN_ID.ONE_OF.SVG_REACT
        ]) {
          if (!rule.oneOfs.has(oneOfId)) {
            continue;
          }
          rule.oneOf(oneOfId).use(jsUseId).before(CHAIN_ID.USE.SVGR).loader(use.get("loader")).options(use.get("options"));
        }
        return true;
      });
    });
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_SVGR_NAME,
  pluginSvgr
});
