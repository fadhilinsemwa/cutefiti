import { createRequire } from 'module';
var require = createRequire(import.meta['url']);


// ../../node_modules/.pnpm/@modern-js+module-tools@2.59.0_typescript@5.5.2/node_modules/@modern-js/module-tools/shims/esm.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// src/index.ts
import path2 from "path";
import { PLUGIN_REACT_NAME } from "@rsbuild/plugin-react";
import deepmerge from "deepmerge";
var SVG_REGEX = /\.svg$/;
var getSvgoDefaultConfig = () => ({
  plugins: [
    {
      name: "preset-default",
      params: {
        overrides: {
          // viewBox is required to resize SVGs with CSS.
          // @see https://github.com/svg/svgo/issues/1128
          removeViewBox: false
        }
      }
    },
    "prefixIds"
  ]
});
var dedupeSvgoPlugins = (config) => {
  if (!config.plugins) {
    return config;
  }
  let mergedPlugins = [];
  for (const plugin of config.plugins) {
    if (typeof plugin === "string") {
      const exist = mergedPlugins.find(
        (item) => item === plugin || typeof item === "object" && item.name === plugin
      );
      if (!exist) {
        mergedPlugins.push(plugin);
      }
      continue;
    }
    const strIndex = mergedPlugins.findIndex(
      (item) => typeof item === "string" && item === plugin.name
    );
    if (strIndex !== -1) {
      mergedPlugins[strIndex] = plugin;
      continue;
    }
    let isMerged = false;
    mergedPlugins = mergedPlugins.map((item) => {
      if (typeof item === "object" && item.name === plugin.name) {
        isMerged = true;
        return deepmerge(item, plugin);
      }
      return item;
    });
    if (!isMerged) {
      mergedPlugins.push(plugin);
    }
  }
  config.plugins = mergedPlugins;
  return config;
};
var PLUGIN_SVGR_NAME = "rsbuild:svgr";
var pluginSvgr = (options = {}) => ({
  name: PLUGIN_SVGR_NAME,
  pre: [PLUGIN_REACT_NAME],
  setup(api) {
    api.modifyBundlerChain(async (chain, { CHAIN_ID, environment }) => {
      const { config } = environment;
      const { dataUriLimit } = config.output;
      const maxSize = typeof dataUriLimit === "number" ? dataUriLimit : dataUriLimit.svg;
      let generatorOptions = {};
      if (chain.module.rules.has(CHAIN_ID.RULE.SVG)) {
        generatorOptions = chain.module.rules.get(CHAIN_ID.RULE.SVG).oneOfs.get(CHAIN_ID.ONE_OF.SVG_URL).get("generator");
        chain.module.rules.delete(CHAIN_ID.RULE.SVG);
      }
      const rule = chain.module.rule(CHAIN_ID.RULE.SVG).test(SVG_REGEX);
      const svgrOptions = deepmerge(
        {
          svgo: true,
          svgoConfig: getSvgoDefaultConfig()
        },
        options.svgrOptions || {}
      );
      svgrOptions.svgoConfig = dedupeSvgoPlugins(svgrOptions.svgoConfig);
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_URL).type("asset/resource").resourceQuery(/(__inline=false|url)/).set("generator", generatorOptions);
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_INLINE).type("asset/inline").resourceQuery(/inline/);
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_REACT).type("javascript/auto").resourceQuery(options.query || /react/).use(CHAIN_ID.USE.SVGR).loader(path2.resolve(__dirname, "./loader.cjs")).options({
        ...svgrOptions,
        exportType: "default"
      }).end();
      const { mixedImport = false } = options;
      if (mixedImport || svgrOptions.exportType) {
        const { exportType = mixedImport ? "named" : void 0 } = svgrOptions;
        const issuerInclude = [
          /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/,
          /\.mdx$/
        ];
        const issuer = options.excludeImporter ? { and: [issuerInclude, { not: options.excludeImporter }] } : issuerInclude;
        const svgRule = rule.oneOf(CHAIN_ID.ONE_OF.SVG);
        if (options.exclude) {
          svgRule.exclude.add(options.exclude);
        }
        svgRule.type("javascript/auto").set("issuer", issuer).use(CHAIN_ID.USE.SVGR).loader(path2.resolve(__dirname, "./loader.cjs")).options({
          ...svgrOptions,
          exportType
        }).end();
        if (mixedImport && exportType === "named") {
          svgRule.use(CHAIN_ID.USE.URL).loader(path2.join(__dirname, "../compiled", "url-loader/index.js")).options({
            limit: maxSize,
            name: generatorOptions?.filename
          });
        }
      }
      rule.oneOf(CHAIN_ID.ONE_OF.SVG_ASSET).type("asset").parser({
        // Inline SVG if size < maxSize
        dataUrlCondition: {
          maxSize
        }
      }).set("generator", generatorOptions);
      const jsRule = chain.module.rules.get(CHAIN_ID.RULE.JS);
      [CHAIN_ID.USE.SWC, CHAIN_ID.USE.BABEL].some((jsUseId) => {
        const use = jsRule.uses.get(jsUseId);
        if (!use) {
          return false;
        }
        for (const oneOfId of [
          CHAIN_ID.ONE_OF.SVG,
          CHAIN_ID.ONE_OF.SVG_REACT
        ]) {
          if (!rule.oneOfs.has(oneOfId)) {
            continue;
          }
          rule.oneOf(oneOfId).use(jsUseId).before(CHAIN_ID.USE.SVGR).loader(use.get("loader")).options(use.get("options"));
        }
        return true;
      });
    });
  }
});
export {
  PLUGIN_SVGR_NAME,
  pluginSvgr
};
