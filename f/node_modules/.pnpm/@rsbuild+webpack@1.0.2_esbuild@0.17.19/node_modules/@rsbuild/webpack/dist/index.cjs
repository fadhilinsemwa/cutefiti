"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/shared.ts
var import_core, getChainUtils, initRsbuildConfig, createDevServer, formatStats, getStatsOptions, stringifyConfig, outputInspectConfigFiles, getRsbuildInspectConfig, chainToConfig, modifyBundlerChain, registerDevHook, registerBuildHook, prettyTime, castArray;
var init_shared = __esm({
  "src/shared.ts"() {
    "use strict";
    import_core = require("@rsbuild/core");
    ({
      getChainUtils,
      initRsbuildConfig,
      createDevServer,
      formatStats,
      getStatsOptions,
      stringifyConfig,
      outputInspectConfigFiles,
      getRsbuildInspectConfig,
      chainToConfig,
      modifyBundlerChain,
      registerDevHook,
      registerBuildHook,
      prettyTime
    } = import_core.__internalHelper);
    castArray = (arr) => {
      if (arr === void 0) {
        return [];
      }
      return Array.isArray(arr) ? arr : [arr];
    };
  }
});

// src/inspectConfig.ts
var inspectConfig_exports = {};
__export(inspectConfig_exports, {
  inspectConfig: () => inspectConfig
});
async function inspectConfig({
  context,
  pluginManager,
  rsbuildOptions,
  bundlerConfigs,
  inspectOptions = {}
}) {
  if (inspectOptions.mode) {
    process.env.NODE_ENV = inspectOptions.mode;
  } else if (!process.env.NODE_ENV) {
    process.env.NODE_ENV = "development";
  }
  const webpackConfigs = bundlerConfigs || (await initConfigs({
    context,
    pluginManager,
    rsbuildOptions
  })).webpackConfigs;
  const rawBundlerConfigs = webpackConfigs.map((config, index) => ({
    name: config.name || String(index),
    content: stringifyConfig(config, inspectOptions.verbose)
  }));
  const {
    rsbuildConfig,
    rawRsbuildConfig,
    environmentConfigs,
    rawEnvironmentConfigs
  } = getRsbuildInspectConfig({
    normalizedConfig: context.normalizedConfig,
    inspectOptions,
    pluginManager
  });
  const outputPath = getInspectOutputPath(context, inspectOptions);
  if (inspectOptions.writeToDisk) {
    await outputInspectConfigFiles({
      rawBundlerConfigs,
      rawEnvironmentConfigs,
      inspectOptions: {
        ...inspectOptions,
        outputPath
      },
      configType: "webpack"
    });
  }
  return {
    rsbuildConfig: rawRsbuildConfig,
    environmentConfigs: rawEnvironmentConfigs.map((r) => r.content),
    bundlerConfigs: rawBundlerConfigs.map((r) => r.content),
    origin: {
      rsbuildConfig,
      environmentConfigs,
      bundlerConfigs: webpackConfigs
    }
  };
}
var import_node_path, getInspectOutputPath;
var init_inspectConfig = __esm({
  "src/inspectConfig.ts"() {
    "use strict";
    import_node_path = require("path");
    init_initConfigs();
    init_shared();
    getInspectOutputPath = (context, inspectOptions) => {
      if (inspectOptions.outputPath) {
        if ((0, import_node_path.isAbsolute)(inspectOptions.outputPath)) {
          return inspectOptions.outputPath;
        }
        return (0, import_node_path.join)(context.distPath, inspectOptions.outputPath);
      }
      return (0, import_node_path.join)(context.distPath, ".rsbuild");
    };
  }
});

// src/webpackConfig.ts
async function modifyWebpackChain(context, utils, chain) {
  import_core2.logger.debug("modify webpack chain");
  const [modifiedChain] = await context.hooks.modifyWebpackChain.callInEnvironment({
    environment: utils.environment.name,
    args: [chain, utils]
  });
  if (utils.environment.config.tools?.webpackChain) {
    for (const item of castArray(utils.environment.config.tools.webpackChain)) {
      item(modifiedChain, utils);
    }
  }
  import_core2.logger.debug("modify webpack chain done");
  return modifiedChain;
}
async function modifyWebpackConfig(context, webpackConfig, utils) {
  import_core2.logger.debug("modify webpack config");
  let [modifiedConfig] = await context.hooks.modifyWebpackConfig.callInEnvironment({
    environment: utils.environment.name,
    args: [webpackConfig, utils]
  });
  if (utils.environment.config.tools?.webpack) {
    modifiedConfig = (0, import_reduce_configs.reduceConfigsWithContext)({
      initial: modifiedConfig,
      config: utils.environment.config.tools.webpack,
      ctx: utils,
      mergeFn: utils.mergeConfig
    });
  }
  import_core2.logger.debug("modify webpack config done");
  return modifiedConfig;
}
async function getChainUtils2(target, environment) {
  const { default: webpack2 } = await import("webpack");
  const nameMap = {
    web: "client",
    node: "server",
    "web-worker": "web-worker"
  };
  return {
    ...getChainUtils(target, environment),
    name: nameMap[target] || "",
    webpack: webpack2,
    HtmlWebpackPlugin: import_core2.__internalHelper.getHTMLPlugin()
  };
}
async function generateWebpackConfig({
  target,
  context,
  environment
}) {
  const chainUtils = await getChainUtils2(
    target,
    context.environments[environment]
  );
  const { default: webpack2 } = await import("webpack");
  const {
    BannerPlugin,
    DefinePlugin,
    IgnorePlugin,
    ProvidePlugin,
    HotModuleReplacementPlugin
  } = webpack2;
  const bundlerChain = await modifyBundlerChain(context, {
    ...chainUtils,
    bundler: {
      BannerPlugin,
      DefinePlugin,
      IgnorePlugin,
      ProvidePlugin,
      HotModuleReplacementPlugin
    }
  });
  const chain = await modifyWebpackChain(context, chainUtils, bundlerChain);
  let webpackConfig = chainToConfig(chain);
  const configUtils = await import_core2.__internalHelper.getConfigUtils(
    webpackConfig,
    chainUtils
  );
  webpackConfig = await modifyWebpackConfig(
    context,
    webpackConfig,
    configUtils
  );
  return webpackConfig;
}
var import_core2, import_reduce_configs;
var init_webpackConfig = __esm({
  "src/webpackConfig.ts"() {
    "use strict";
    import_core2 = require("@rsbuild/core");
    import_reduce_configs = require("reduce-configs");
    init_shared();
  }
});

// src/initConfigs.ts
async function initConfigs({
  context,
  pluginManager,
  rsbuildOptions
}) {
  const normalizedConfig = await initRsbuildConfig({
    context,
    pluginManager
  });
  const webpackConfigs = await Promise.all(
    Object.entries(normalizedConfig.environments).map(
      ([environment, config]) => generateWebpackConfig({
        target: config.output.target,
        context,
        environment
      })
    )
  );
  if (import_core3.logger.level === "verbose") {
    const inspect = () => {
      const inspectOptions = {
        verbose: true,
        writeToDisk: true
      };
      inspectConfig({
        context,
        pluginManager,
        inspectOptions,
        rsbuildOptions,
        bundlerConfigs: webpackConfigs
      });
    };
    context.hooks.onBeforeBuild.tap(({ isFirstCompile }) => {
      if (isFirstCompile) {
        inspect();
      }
    });
    context.hooks.onAfterStartDevServer.tap(inspect);
  }
  return {
    webpackConfigs
  };
}
var import_core3;
var init_initConfigs = __esm({
  "src/initConfigs.ts"() {
    "use strict";
    import_core3 = require("@rsbuild/core");
    init_inspectConfig();
    init_shared();
    init_webpackConfig();
  }
});

// src/createCompiler.ts
var createCompiler_exports = {};
__export(createCompiler_exports, {
  createCompiler: () => createCompiler
});
async function createCompiler(options) {
  import_core4.logger.debug("create compiler");
  const { context } = options;
  const { webpackConfigs } = await initConfigs(options);
  await context.hooks.onBeforeCreateCompiler.call({
    bundlerConfigs: webpackConfigs,
    environments: context.environments
  });
  const { default: webpack2 } = await import("webpack");
  const compiler = webpackConfigs.length === 1 ? webpack2(webpackConfigs[0]) : webpack2(webpackConfigs);
  const done = (stats) => {
    const { message, level } = formatStats(
      stats,
      getStatsOptions(compiler)
    );
    if (level === "error") {
      import_core4.logger.error(message);
    }
    if (level === "warning") {
      import_core4.logger.warn(message);
    }
  };
  compiler.hooks.done.tap("rsbuild:done", (stats) => {
    done(stats);
  });
  if (context.normalizedConfig?.mode === "development") {
    registerDevHook({
      compiler,
      context,
      bundlerConfigs: webpackConfigs,
      MultiStatsCtor: import_MultiStats.default
    });
  }
  await context.hooks.onAfterCreateCompiler.call({
    compiler,
    environments: context.environments
  });
  import_core4.logger.debug("create compiler done");
  return {
    compiler,
    webpackConfigs
  };
}
var import_core4, import_MultiStats;
var init_createCompiler = __esm({
  "src/createCompiler.ts"() {
    "use strict";
    import_core4 = require("@rsbuild/core");
    import_MultiStats = __toESM(require("webpack/lib/MultiStats.js"));
    init_initConfigs();
    init_shared();
  }
});

// ../../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "../../../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// ../../../node_modules/.pnpm/astral-regex@2.0.0/node_modules/astral-regex/index.js
var require_astral_regex = __commonJS({
  "../../../node_modules/.pnpm/astral-regex@2.0.0/node_modules/astral-regex/index.js"(exports2, module2) {
    "use strict";
    var regex = "[\uD800-\uDBFF][\uDC00-\uDFFF]";
    var astralRegex = (options) => options && options.exact ? new RegExp(`^${regex}$`) : new RegExp(regex, "g");
    module2.exports = astralRegex;
  }
});

// ../../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
    "use strict";
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color3 = args % 10;
      if (color3 === 0 || color3 === 7) {
        if (args > 50) {
          color3 += 3.5;
        }
        color3 = color3 / 10.5 * 255;
        return [color3, color3, color3];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color3 & 1) * mult * 255;
      const g = (color3 >> 1 & 1) * mult * 255;
      const b = (color3 >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS({
  "../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// ../../../node_modules/.pnpm/slice-ansi@3.0.0/node_modules/slice-ansi/index.js
var require_slice_ansi = __commonJS({
  "../../../node_modules/.pnpm/slice-ansi@3.0.0/node_modules/slice-ansi/index.js"(exports2, module2) {
    "use strict";
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var astralRegex = require_astral_regex();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = [
      "\x1B",
      "Â›"
    ];
    var wrapAnsi = (code) => `${ESCAPES[0]}[${code}m`;
    var checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
      let output = [];
      ansiCodes = [...ansiCodes];
      for (let ansiCode of ansiCodes) {
        const ansiCodeOrigin = ansiCode;
        if (ansiCode.match(";")) {
          ansiCode = ansiCode.split(";")[0][0] + "0";
        }
        const item = ansiStyles.codes.get(parseInt(ansiCode, 10));
        if (item) {
          const indexEscape = ansiCodes.indexOf(item.toString());
          if (indexEscape >= 0) {
            ansiCodes.splice(indexEscape, 1);
          } else {
            output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));
          }
        } else if (isEscapes) {
          output.push(wrapAnsi(0));
          break;
        } else {
          output.push(wrapAnsi(ansiCodeOrigin));
        }
      }
      if (isEscapes) {
        output = output.filter((element, index) => output.indexOf(element) === index);
        if (endAnsiCode !== void 0) {
          const fistEscapeCode = wrapAnsi(ansiStyles.codes.get(parseInt(endAnsiCode, 10)));
          output = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
        }
      }
      return output.join("");
    };
    module2.exports = (string, begin, end) => {
      const characters = [...string.normalize()];
      const ansiCodes = [];
      end = typeof end === "number" ? end : characters.length;
      let isInsideEscape = false;
      let ansiCode;
      let visible = 0;
      let output = "";
      for (const [index, character] of characters.entries()) {
        let leftEscape = false;
        if (ESCAPES.includes(character)) {
          const code = /\d[^m]*/.exec(string.slice(index, index + 18));
          ansiCode = code && code.length > 0 ? code[0] : void 0;
          if (visible < end) {
            isInsideEscape = true;
            if (ansiCode !== void 0) {
              ansiCodes.push(ansiCode);
            }
          }
        } else if (isInsideEscape && character === "m") {
          isInsideEscape = false;
          leftEscape = true;
        }
        if (!isInsideEscape && !leftEscape) {
          ++visible;
        }
        if (!astralRegex({ exact: true }).test(character) && isFullwidthCodePoint(character.codePointAt())) {
          ++visible;
        }
        if (visible > begin && visible <= end) {
          output += character;
        } else if (visible === begin && !isInsideEscape && ansiCode !== void 0) {
          output = checkAnsi(ansiCodes);
        } else if (visible >= end) {
          output += checkAnsi(ansiCodes, true, ansiCode);
          break;
        }
      }
      return output;
    };
  }
});

// ../../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "../../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// ../../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "../../../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// ../../../node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js
var require_string_width = __commonJS({
  "../../../node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// ../../../node_modules/.pnpm/cli-truncate@2.1.0/node_modules/cli-truncate/index.js
var require_cli_truncate = __commonJS({
  "../../../node_modules/.pnpm/cli-truncate@2.1.0/node_modules/cli-truncate/index.js"(exports2, module2) {
    "use strict";
    var sliceAnsi = require_slice_ansi();
    var stringWidth = require_string_width();
    function getIndexOfNearestSpace(string, index, shouldSearchRight) {
      if (string.charAt(index) === " ") {
        return index;
      }
      for (let i = 1; i <= 3; i++) {
        if (shouldSearchRight) {
          if (string.charAt(index + i) === " ") {
            return index + i;
          }
        } else if (string.charAt(index - i) === " ") {
          return index - i;
        }
      }
      return index;
    }
    module2.exports = (text, columns, options) => {
      options = {
        position: "end",
        preferTruncationOnSpace: false,
        ...options
      };
      const { position, space, preferTruncationOnSpace } = options;
      let ellipsis = "â€¦";
      let ellipsisWidth = 1;
      if (typeof text !== "string") {
        throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
      }
      if (typeof columns !== "number") {
        throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
      }
      if (columns < 1) {
        return "";
      }
      if (columns === 1) {
        return ellipsis;
      }
      const length = stringWidth(text);
      if (length <= columns) {
        return text;
      }
      if (position === "start") {
        if (preferTruncationOnSpace) {
          const nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, true);
          return ellipsis + sliceAnsi(text, nearestSpace, length).trim();
        }
        if (space === true) {
          ellipsis += " ";
          ellipsisWidth = 2;
        }
        return ellipsis + sliceAnsi(text, length - columns + ellipsisWidth, length);
      }
      if (position === "middle") {
        if (space === true) {
          ellipsis = " " + ellipsis + " ";
          ellipsisWidth = 3;
        }
        const half = Math.floor(columns / 2);
        if (preferTruncationOnSpace) {
          const spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half);
          const spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, true);
          return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + ellipsis + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
        }
        return sliceAnsi(text, 0, half) + ellipsis + sliceAnsi(text, length - (columns - half) + ellipsisWidth, length);
      }
      if (position === "end") {
        if (preferTruncationOnSpace) {
          const nearestSpace = getIndexOfNearestSpace(text, columns - 1);
          return sliceAnsi(text, 0, nearestSpace) + ellipsis;
        }
        if (space === true) {
          ellipsis = " " + ellipsis;
          ellipsisWidth = 2;
        }
        return sliceAnsi(text, 0, columns - ellipsisWidth) + ellipsis;
      }
      throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
    };
  }
});

// ../../../node_modules/.pnpm/patch-console@1.0.0/node_modules/patch-console/build/index.js
var require_build = __commonJS({
  "../../../node_modules/.pnpm/patch-console@1.0.0/node_modules/patch-console/build/index.js"(exports2, module2) {
    "use strict";
    var stream_1 = require("stream");
    var CONSOLE_METHODS = [
      "assert",
      "count",
      "countReset",
      "debug",
      "dir",
      "dirxml",
      "error",
      "group",
      "groupCollapsed",
      "groupEnd",
      "info",
      "log",
      "table",
      "time",
      "timeEnd",
      "timeLog",
      "trace",
      "warn"
    ];
    var originalMethods = {};
    var patchConsole2 = (callback) => {
      const stdout = new stream_1.PassThrough();
      const stderr = new stream_1.PassThrough();
      stdout.write = (data) => callback("stdout", data);
      stderr.write = (data) => callback("stderr", data);
      const internalConsole = new console.Console(stdout, stderr);
      for (const method of CONSOLE_METHODS) {
        originalMethods[method] = console[method];
        console[method] = internalConsole[method];
      }
      return () => {
        for (const method of CONSOLE_METHODS) {
          console[method] = originalMethods[method];
        }
        originalMethods = {};
      };
    };
    module2.exports = patchConsole2;
  }
});

// src/progress/helpers/utils.ts
var clamp;
var init_utils = __esm({
  "src/progress/helpers/utils.ts"() {
    "use strict";
    clamp = (x, min, max) => {
      return Math.min(max, Math.max(min, x));
    };
  }
});

// src/progress/helpers/bar.ts
var import_cli_truncate, import_picocolors, defaultOption, padding, FULL_WIDTH, MIDDLE_WIDTH, renderBar;
var init_bar = __esm({
  "src/progress/helpers/bar.ts"() {
    "use strict";
    import_cli_truncate = __toESM(require_cli_truncate());
    import_picocolors = __toESM(require("picocolors"));
    init_utils();
    defaultOption = {
      total: 100,
      current: 0,
      color: "green",
      bgColor: "gray",
      char: "â”",
      width: 25,
      buildIcon: "â—¯",
      errorIcon: "âœ–",
      errorInfo: "compile failed",
      message: "",
      done: false,
      spaceWidth: 1,
      messageWidth: 25,
      messageColor: "gray",
      id: "",
      maxIdLen: 16,
      hasErrors: false
    };
    padding = (id, maxLen) => {
      const left = Math.floor((maxLen - id.length) / 2);
      const right = maxLen - left - id.length;
      return " ".repeat(left) + id + " ".repeat(right);
    };
    FULL_WIDTH = 70;
    MIDDLE_WIDTH = 40;
    renderBar = (option) => {
      const mergedOptions = {
        ...defaultOption,
        ...option
      };
      const {
        total,
        done,
        buildIcon,
        errorIcon,
        errorInfo,
        width,
        current,
        color: color3,
        bgColor,
        char,
        message,
        messageWidth,
        spaceWidth,
        messageColor,
        maxIdLen,
        hasErrors
      } = mergedOptions;
      const space = " ".repeat(spaceWidth);
      const percent = clamp(Math.floor(current / total * 100), 0, 100);
      const barColor = import_picocolors.default[color3];
      const backgroundColor = import_picocolors.default[bgColor];
      const doneColor = hasErrors ? import_picocolors.default.red : barColor;
      const idColor = done ? doneColor : barColor;
      const id = mergedOptions.id ? idColor(padding(mergedOptions.id, maxIdLen)) : "";
      const { columns: terminalWidth = FULL_WIDTH } = process.stdout;
      if (done) {
        if (hasErrors) {
          const message2 = import_picocolors.default.bold(doneColor(errorInfo));
          if (terminalWidth >= MIDDLE_WIDTH) {
            return [idColor(errorIcon), id, doneColor(`${space}${message2}`)].join(
              ""
            );
          }
          return [id, doneColor(`${message2}`)].join("");
        }
        return "";
      }
      const msgStr = import_picocolors.default[messageColor](
        (0, import_cli_truncate.default)(message, messageWidth, { position: "start" })
      );
      const left = clamp(Math.floor(percent * width / 100), 0, width);
      const right = clamp(width - left, 0, width);
      const barStr = `${barColor(char.repeat(left))}${backgroundColor(
        char.repeat(right)
      )}`;
      const percentStr = `${percent.toString().padStart(3)}%`;
      if (terminalWidth >= FULL_WIDTH) {
        return [
          idColor(buildIcon),
          id,
          space,
          barStr,
          space,
          percentStr,
          space,
          msgStr
        ].join("");
      }
      if (terminalWidth >= MIDDLE_WIDTH) {
        return [idColor(buildIcon), id, space, barStr, space, percentStr].join("");
      }
      return [idColor(buildIcon), id, space, percentStr].join("");
    };
  }
});

// ../../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS({
  "../../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js"(exports2, module2) {
    "use strict";
    var ansiEscapes2 = module2.exports;
    module2.exports.default = ansiEscapes2;
    var ESC = "\x1B[";
    var OSC = "\x1B]";
    var BEL = "\x07";
    var SEP = ";";
    var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    ansiEscapes2.cursorTo = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      if (typeof y !== "number") {
        return ESC + (x + 1) + "G";
      }
      return ESC + (y + 1) + ";" + (x + 1) + "H";
    };
    ansiEscapes2.cursorMove = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      let ret = "";
      if (x < 0) {
        ret += ESC + -x + "D";
      } else if (x > 0) {
        ret += ESC + x + "C";
      }
      if (y < 0) {
        ret += ESC + -y + "A";
      } else if (y > 0) {
        ret += ESC + y + "B";
      }
      return ret;
    };
    ansiEscapes2.cursorUp = (count = 1) => ESC + count + "A";
    ansiEscapes2.cursorDown = (count = 1) => ESC + count + "B";
    ansiEscapes2.cursorForward = (count = 1) => ESC + count + "C";
    ansiEscapes2.cursorBackward = (count = 1) => ESC + count + "D";
    ansiEscapes2.cursorLeft = ESC + "G";
    ansiEscapes2.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
    ansiEscapes2.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
    ansiEscapes2.cursorGetPosition = ESC + "6n";
    ansiEscapes2.cursorNextLine = ESC + "E";
    ansiEscapes2.cursorPrevLine = ESC + "F";
    ansiEscapes2.cursorHide = ESC + "?25l";
    ansiEscapes2.cursorShow = ESC + "?25h";
    ansiEscapes2.eraseLines = (count) => {
      let clear = "";
      for (let i = 0; i < count; i++) {
        clear += ansiEscapes2.eraseLine + (i < count - 1 ? ansiEscapes2.cursorUp() : "");
      }
      if (count) {
        clear += ansiEscapes2.cursorLeft;
      }
      return clear;
    };
    ansiEscapes2.eraseEndLine = ESC + "K";
    ansiEscapes2.eraseStartLine = ESC + "1K";
    ansiEscapes2.eraseLine = ESC + "2K";
    ansiEscapes2.eraseDown = ESC + "J";
    ansiEscapes2.eraseUp = ESC + "1J";
    ansiEscapes2.eraseScreen = ESC + "2J";
    ansiEscapes2.scrollUp = ESC + "S";
    ansiEscapes2.scrollDown = ESC + "T";
    ansiEscapes2.clearScreen = "\x1Bc";
    ansiEscapes2.clearTerminal = process.platform === "win32" ? `${ansiEscapes2.eraseScreen}${ESC}0f` : (
      // 1. Erases the screen (Only done in case `2` is not supported)
      // 2. Erases the whole screen including scrollback buffer
      // 3. Moves cursor to the top-left position
      // More info: https://www.real-world-systems.com/docs/ANSIcode.html
      `${ansiEscapes2.eraseScreen}${ESC}3J${ESC}H`
    );
    ansiEscapes2.beep = BEL;
    ansiEscapes2.link = (text, url) => {
      return [
        OSC,
        "8",
        SEP,
        SEP,
        url,
        BEL,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        BEL
      ].join("");
    };
    ansiEscapes2.image = (buffer, options = {}) => {
      let ret = `${OSC}1337;File=inline=1`;
      if (options.width) {
        ret += `;width=${options.width}`;
      }
      if (options.height) {
        ret += `;height=${options.height}`;
      }
      if (options.preserveAspectRatio === false) {
        ret += ";preserveAspectRatio=0";
      }
      return ret + ":" + buffer.toString("base64") + BEL;
    };
    ansiEscapes2.iTerm = {
      setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
      annotation: (message, options = {}) => {
        let ret = `${OSC}1337;`;
        const hasX = typeof options.x !== "undefined";
        const hasY = typeof options.y !== "undefined";
        if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        }
        message = message.replace(/\|/g, "");
        ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
        if (options.length > 0) {
          ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
        } else {
          ret += message;
        }
        return ret + BEL;
      }
    };
  }
});

// src/progress/helpers/log.ts
var import_ansi_escapes, create;
var init_log = __esm({
  "src/progress/helpers/log.ts"() {
    "use strict";
    import_ansi_escapes = __toESM(require_ansi_escapes());
    create = (stream) => {
      let previousLineCount = 0;
      let previousOutput = "";
      const render = (str) => {
        const output = `${str}
`;
        if (output === previousOutput) {
          return;
        }
        previousOutput = output;
        stream.write(import_ansi_escapes.default.eraseLines(previousLineCount) + output);
        previousLineCount = output.split("\n").length;
      };
      render.clear = () => {
        stream.write(import_ansi_escapes.default.eraseLines(previousLineCount));
        previousOutput = "";
        previousLineCount = 0;
      };
      render.done = () => {
        previousOutput = "";
        previousLineCount = 0;
      };
      return render;
    };
  }
});

// src/progress/helpers/bus.ts
var import_node_console, import_cli_truncate2, import_patch_console, colorList, getProgressColor, Bus, bus;
var init_bus = __esm({
  "src/progress/helpers/bus.ts"() {
    "use strict";
    import_node_console = require("console");
    import_cli_truncate2 = __toESM(require_cli_truncate());
    import_patch_console = __toESM(require_build());
    init_bar();
    init_log();
    colorList = ["green", "cyan", "yellow", "blue", "magenta"];
    getProgressColor = (index) => colorList[index % colorList.length];
    Bus = class {
      constructor() {
        __publicField(this, "states", []);
        __publicField(this, "log");
        __publicField(this, "restore");
        __publicField(this, "prevOutput");
        __publicField(this, "destroyed", false);
        this.prevOutput = "";
        this.log = create(process.stdout);
        console.Console = import_node_console.Console;
        this.restore = (0, import_patch_console.default)((type, data) => {
          this.writeToStd(type, data);
        });
      }
      update(state) {
        const index = this.states.findIndex((i) => i.id === state.id);
        if (index === -1) {
          this.states.push(state);
          return;
        }
        this.states[index] = state;
      }
      writeToStd(type = "stdout", data) {
        this.log.clear();
        if (data) {
          if (type === "stdout") {
            process.stdout.write(data);
          } else if (type === "stderr") {
            process.stderr.write(data);
          }
        }
        this.log(this.prevOutput);
      }
      render() {
        const maxIdLen = Math.max(...this.states.map((i) => i.id?.length ?? 0)) + 2;
        const { columns = FULL_WIDTH } = process.stdout;
        this.prevOutput = this.states.map((i, k) => {
          const bar = renderBar({
            maxIdLen,
            color: i.color ?? getProgressColor(k),
            ...i
          });
          if (bar) {
            return (0, import_cli_truncate2.default)(bar, columns, { position: "end" });
          }
          return null;
        }).filter((item) => item !== null).join("\n");
        this.writeToStd();
      }
      destroy() {
        if (!this.destroyed) {
          this.restore();
        }
        this.destroyed = true;
      }
      clear() {
        this.log.clear();
        this.log.done();
      }
    };
    bus = new Bus();
  }
});

// src/progress/helpers/types.ts
var init_types = __esm({
  "src/progress/helpers/types.ts"() {
    "use strict";
  }
});

// src/progress/helpers/percentage.ts
var createFriendlyPercentage;
var init_percentage = __esm({
  "src/progress/helpers/percentage.ts"() {
    "use strict";
    createFriendlyPercentage = () => {
      let prevPercentage = 0;
      return (percentage) => {
        if (percentage === 0 || percentage === 1) {
          prevPercentage = 0;
          return percentage;
        }
        if (percentage <= prevPercentage) {
          let step = 0;
          if (prevPercentage < 0.3) {
            step = 1e-3;
          } else if (prevPercentage < 0.6) {
            step = 2e-3;
          } else if (prevPercentage < 0.8) {
            step = 4e-3;
          } else if (prevPercentage < 0.99) {
            step = 2e-3;
          }
          prevPercentage += step;
          return prevPercentage;
        }
        prevPercentage = percentage;
        return percentage;
      };
    };
  }
});

// src/progress/helpers/index.ts
var init_helpers = __esm({
  "src/progress/helpers/index.ts"() {
    "use strict";
    init_bus();
    init_bar();
    init_types();
    init_percentage();
  }
});

// src/progress/helpers/nonTty.ts
function createNonTTYLogger() {
  let prevPercentage = 0;
  const log = ({
    id,
    done,
    current,
    hasErrors,
    compileTime
  }) => {
    const suffix = import_picocolors2.default.gray(`(${id})`);
    if (done) {
      if (prevPercentage === 100) {
        return;
      }
      prevPercentage = 100;
      if (hasErrors) {
        import_core5.logger.error(`Compile failed in ${compileTime} ${suffix}`);
      } else {
        import_core5.logger.ready(`Compiled in ${compileTime} ${suffix}`);
      }
    } else if (current - prevPercentage > 10) {
      prevPercentage = current;
      import_core5.logger.info(`Compile progress: ${current.toFixed(0)}% ${suffix}`);
    }
  };
  return {
    log
  };
}
var import_core5, import_picocolors2;
var init_nonTty = __esm({
  "src/progress/helpers/nonTty.ts"() {
    "use strict";
    import_core5 = require("@rsbuild/core");
    import_picocolors2 = __toESM(require("picocolors"));
  }
});

// src/progress/ProgressPlugin.ts
var ProgressPlugin_exports = {};
__export(ProgressPlugin_exports, {
  ProgressPlugin: () => ProgressPlugin
});
var import_core6, import_picocolors3, import_webpack, ProgressPlugin;
var init_ProgressPlugin = __esm({
  "src/progress/ProgressPlugin.ts"() {
    "use strict";
    import_core6 = require("@rsbuild/core");
    import_picocolors3 = __toESM(require("picocolors"));
    import_webpack = __toESM(require("webpack"));
    init_shared();
    init_helpers();
    init_nonTty();
    ProgressPlugin = class extends import_webpack.default.ProgressPlugin {
      constructor(options) {
        const { id = "Rsbuild" } = options;
        const nonTTYLogger = createNonTTYLogger();
        const friendlyPercentage = createFriendlyPercentage();
        super({
          activeModules: false,
          entries: true,
          modules: true,
          modulesCount: 5e3,
          profile: false,
          dependencies: true,
          dependenciesCount: 1e4,
          percentBy: null,
          handler: (originalPercentage, message) => {
            const percentage = friendlyPercentage(originalPercentage);
            const done = percentage === 1;
            if (process.stdout.isTTY) {
              bus.update({
                id,
                current: percentage * 100,
                message,
                done,
                hasErrors: this.hasCompileErrors
              });
              bus.render();
            } else {
              nonTTYLogger.log({
                id,
                done,
                current: percentage * 100,
                hasErrors: this.hasCompileErrors,
                compileTime: this.compileTime
              });
            }
          }
        });
        __publicField(this, "name", "ProgressPlugin");
        __publicField(this, "id");
        __publicField(this, "hasCompileErrors", false);
        __publicField(this, "compileTime", null);
        this.id = id;
      }
      apply(compiler) {
        super.apply(compiler);
        let startTime = null;
        compiler.hooks.compile.tap(this.name, () => {
          this.compileTime = null;
          startTime = process.hrtime();
        });
        compiler.hooks.done.tap(this.name, (stat) => {
          if (startTime) {
            this.hasCompileErrors = stat.hasErrors();
            const hrtime = process.hrtime(startTime);
            const seconds = hrtime[0] + hrtime[1] / 1e9;
            this.compileTime = prettyTime(seconds);
            startTime = null;
            if (!this.hasCompileErrors) {
              const suffix = this.id ? import_picocolors3.default.gray(` (${this.id})`) : "";
              import_core6.logger.ready(`Compiled in ${this.compileTime} ${suffix}`);
            }
          }
        });
      }
    };
  }
});

// src/plugin.ts
var plugin_exports = {};
__export(plugin_exports, {
  pluginAdaptor: () => pluginAdaptor
});
async function applyTsConfigPathsPlugin({
  chain,
  CHAIN_ID,
  mainFields,
  extensions,
  configFile
}) {
  const { TsconfigPathsPlugin } = await import("tsconfig-paths-webpack-plugin");
  chain.resolve.plugin(CHAIN_ID.RESOLVE_PLUGIN.TS_CONFIG_PATHS).use(TsconfigPathsPlugin, [
    {
      configFile,
      extensions,
      // https://github.com/dividab/tsconfig-paths-webpack-plugin/pull/106
      mainFields
    }
  ]);
}
function isWebTarget(target) {
  const targets = castArray(target);
  return targets.includes("web") || target.includes("web-worker");
}
var import_node_fs, getMainFields, pluginAdaptor;
var init_plugin = __esm({
  "src/plugin.ts"() {
    "use strict";
    import_node_fs = __toESM(require("fs"));
    init_shared();
    getMainFields = (chain, target) => {
      const mainFields = chain.resolve.mainFields.values();
      if (mainFields.length) {
        return mainFields;
      }
      if (isWebTarget(target)) {
        return ["browser", "module", "main"];
      }
      return ["module", "main"];
    };
    pluginAdaptor = () => ({
      name: "rsbuild-webpack:adaptor",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID, environment, target }) => {
          const { config, tsconfigPath } = environment;
          if (tsconfigPath && config.source.aliasStrategy === "prefer-tsconfig") {
            await applyTsConfigPathsPlugin({
              chain,
              CHAIN_ID,
              configFile: tsconfigPath,
              mainFields: getMainFields(chain, target),
              extensions: chain.resolve.extensions.values()
            });
          }
          const progress = config.dev.progressBar ?? true;
          if (progress) {
            const { ProgressPlugin: ProgressPlugin2 } = await Promise.resolve().then(() => (init_ProgressPlugin(), ProgressPlugin_exports));
            chain.plugin(CHAIN_ID.PLUGIN.PROGRESS).use(ProgressPlugin2, [
              {
                id: environment.name,
                ...progress === true ? {} : progress
              }
            ]);
          }
          const { copy } = config.output;
          if (copy) {
            const { default: CopyPlugin } = await import("copy-webpack-plugin");
            const options = Array.isArray(copy) ? { patterns: copy } : copy;
            chain.plugin(CHAIN_ID.PLUGIN.COPY).use(CopyPlugin, [
              // @ts-expect-error to type mismatch
              options
            ]);
          }
        });
        api.modifyWebpackConfig(async (config) => {
          const copyPlugin = config.plugins?.find(
            (item) => item?.constructor.name === "CopyPlugin"
          );
          if (copyPlugin) {
            const isContextNotExists = copyPlugin.patterns.every(
              (pattern) => typeof pattern !== "string" && pattern.context && !import_node_fs.default.existsSync(pattern.context)
            );
            if (isContextNotExists) {
              config.plugins = config.plugins?.filter(
                (item) => item?.constructor.name !== "CopyPlugin"
              );
            }
          }
        });
      }
    });
  }
});

// src/build.ts
var build_exports = {};
__export(build_exports, {
  build: () => build
});
var import_core7, import_MultiStats2, build;
var init_build = __esm({
  "src/build.ts"() {
    "use strict";
    import_core7 = require("@rsbuild/core");
    import_MultiStats2 = __toESM(require("webpack/lib/MultiStats.js"));
    init_createCompiler();
    init_shared();
    build = async (initOptions, { watch, compiler: customCompiler } = {}) => {
      const { context } = initOptions;
      let compiler;
      let bundlerConfigs;
      if (customCompiler) {
        compiler = customCompiler;
      } else {
        const result = await createCompiler(initOptions);
        compiler = result.compiler;
        bundlerConfigs = result.webpackConfigs;
      }
      registerBuildHook({
        context,
        bundlerConfigs,
        compiler,
        isWatch: Boolean(watch),
        MultiStatsCtor: import_MultiStats2.default
      });
      if (watch) {
        const watching = compiler.watch({}, (err) => {
          if (err) {
            import_core7.logger.error(err);
          }
        });
        return {
          close: () => new Promise((resolve) => {
            watching.close(resolve);
          })
        };
      }
      const { stats } = await new Promise((resolve, reject) => {
        compiler.run((err, stats2) => {
          if (err) {
            reject(err);
          } else if (stats2?.hasErrors()) {
            reject(new Error("Rspack build failed!"));
          } else {
            compiler.close((closeErr) => {
              closeErr && import_core7.logger.error(closeErr);
              resolve({ stats: stats2 });
            });
          }
        });
      });
      return {
        stats,
        // This close method is a noop in non-watch mode
        // In watch mode, it's defined above to stop watching
        close: async () => {
        }
      };
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  webpackProvider: () => webpackProvider
});
module.exports = __toCommonJS(src_exports);

// src/provider.ts
init_initConfigs();
init_shared();
var webpackProvider = async ({
  context,
  pluginManager,
  rsbuildOptions,
  setCssExtractPlugin
}) => {
  const { default: cssExtractPlugin } = await import("mini-css-extract-plugin");
  setCssExtractPlugin(cssExtractPlugin);
  const createCompiler2 = async () => {
    const { createCompiler: createCompiler3 } = await Promise.resolve().then(() => (init_createCompiler(), createCompiler_exports));
    const result = await createCompiler3({
      context,
      pluginManager,
      rsbuildOptions
    });
    return result.compiler;
  };
  const { pluginAdaptor: pluginAdaptor2 } = await Promise.resolve().then(() => (init_plugin(), plugin_exports));
  pluginManager.addPlugins([pluginAdaptor2()]);
  return {
    bundler: "webpack",
    createCompiler: createCompiler2,
    async initConfigs() {
      const { webpackConfigs } = await initConfigs({
        context,
        pluginManager,
        rsbuildOptions
      });
      return webpackConfigs;
    },
    async createDevServer(options) {
      const config = await initRsbuildConfig({ context, pluginManager });
      return createDevServer(
        { context, pluginManager, rsbuildOptions },
        createCompiler2,
        config,
        options
      );
    },
    async startDevServer(options) {
      const config = await initRsbuildConfig({
        context,
        pluginManager
      });
      const server = await createDevServer(
        {
          context,
          pluginManager,
          rsbuildOptions
        },
        createCompiler2,
        config,
        options
      );
      return server.listen();
    },
    async build(options) {
      const { build: build2 } = await Promise.resolve().then(() => (init_build(), build_exports));
      return build2({ context, pluginManager, rsbuildOptions }, options);
    },
    async inspectConfig(inspectOptions) {
      const { inspectConfig: inspectConfig2 } = await Promise.resolve().then(() => (init_inspectConfig(), inspectConfig_exports));
      return await inspectConfig2({
        context,
        pluginManager,
        rsbuildOptions,
        inspectOptions
      });
    }
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  webpackProvider
});
